<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>贝索斯</title>
      <link href="/posts/7e3d936b/"/>
      <url>/posts/7e3d936b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="聪明是一种天赋，善良是一种选择"><a href="#聪明是一种天赋，善良是一种选择" class="headerlink" title="聪明是一种天赋，善良是一种选择"></a>聪明是一种天赋，善良是一种选择</h1><div style="width: 360px;"><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/贝索斯-聪明是一种天赋，善良是一种选择 - 抖音.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>董宇辉</title>
      <link href="/posts/424d562f/"/>
      <url>/posts/424d562f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="看名人演讲"><a href="#看名人演讲" class="headerlink" title="看名人演讲"></a>看名人演讲</h1><div style="width: 360px;"><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/董宇辉听演讲 - 抖音.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>赵玉平</title>
      <link href="/posts/d63cb66d/"/>
      <url>/posts/d63cb66d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li><code>你相信自己是什么样的人，比你实际上是什么样更重要。人们都是经由这样的信念引导，一点一点走向成功，走向幸福的。</code>所以从哲学上讲啊，<br>我是谁这个问题会伴随我们的一生。它决定我们的起落沉浮，引导我们的喜怒哀乐，陪伴我们的生老病死。一个英雄在做出英雄行为之前，<br>他从内心深处一开始就相信自己是英雄，所以规律告诉我们，先有内在的英雄信念，然后才会有外在的英雄行为。<br>这个社会生活当中有个简单的规律，就是一个人跟谁比，就决定了这个人他自己是谁。大家想一想，跟强者比的人就会越来越强，跟弱者比的人肯定会越来越弱。</li><li></li></ol><div style="width: 500px;"><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/赵玉平-相信的力量.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>方洪波</title>
      <link href="/posts/aef4674d/"/>
      <url>/posts/aef4674d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语句"><a href="#经典语句" class="headerlink" title="经典语句"></a>经典语句</h1><ol><li><code>我对企业的成功视而不见，每天思考的都是失败。</code></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>白岩松</title>
      <link href="/posts/90873832/"/>
      <url>/posts/90873832/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语句"><a href="#经典语句" class="headerlink" title="经典语句"></a>经典语句</h1><ol><li>人生是一个围棋盘，当你读的书很少的时候，这个棋盘上点的子很少，他不成势，随时可能被别人吃掉。<code>人找书是很难的，但是书找书是非常容易的</code>，就是越读书越知<br>道该读什么书，书会带着你去读书。这个围棋盘上的子连在一起，那它就会成势了。</li><li></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>影响力</title>
      <link href="/posts/9bddc639/"/>
      <url>/posts/9bddc639/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="互惠原则-Reciprocity"><a href="#互惠原则-Reciprocity" class="headerlink" title="互惠原则 (Reciprocity)"></a>互惠原则 (Reciprocity)</h2><p>内涵： 我们倾向于回报他人的恩惠、礼物、帮助或让步。这种“亏欠感”是强大的社会规范。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 心理学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>颠覆者</title>
      <link href="/posts/13bd6443/"/>
      <url>/posts/13bd6443/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li><code>作为一个年轻人，真正幸运的并不是在很年轻时就得到了很多财富，而是在成年之前就感觉到了自己来到这个世界的使命，有了目标之后努力才不盲目。</code></li><li><code>丹尼尔·科伊尔在《一万小时天才理论》里说：“在未来的某些时候，也许已经发生了——你会坠入爱河。不是和某个人，而是和某个你自己的想法——关于你想成为谁，关于你生来会成为谁。这种爱，这种激情，就是发展才能的原始燃料。”而我在那个时候，找到了我的原始燃料。</code></li><li><code>我想我和同龄人最大的区别是——我更喜欢实践。</code></li><li>通过很多事情，我理解了这样一个道理，<code>做一件事情总要不计回报，一旦投入了全部感情，最后的回报总会出其不意地到来。我最享受的不是做事的最终结果，而是在投入的过程中，那种说不出来的内心的平静。</code></li><li>多年之后，我读到奥普拉的一段话：“<code>（我感觉）充满了希望、满足感和说不清的愉悦。我坚信，甚至在每天从不同角度轰炸我们的疯狂之中，存在着，仍然存在着，这一直都在的安宁。</code>”而我的计算机世界里，正充满了这种安宁。</li><li><code>但是我当时已经发现了不抱怨生活的妙处。如果鱼和熊掌不能兼得，只要我的核心需求能被满足就好，其他的一切我都可以忽略。</code></li><li><code>很多互联网的成功其实都不是技术的成功，而是商业模式和理念的成功。</code></li><li><code>不知腐鼠成滋味，猜意鹓雏竟未休.</code></li><li><code>真正的光明绝不是没有黑暗的时间，只是永不被黑暗所掩蔽罢了。真正的英雄绝不是没有卑下的情操，只是永不被卑下的情操所屈服罢了。</code></li><li><code>记得《创业维艰》里有段话：“人们总是问我：‘当一名成功的CEO的秘诀是什么？’遗憾的是，根本没有秘诀。如果说存在这样一种技巧，那就是看其专心致志的能力和在无路可走时选择最佳路线的能力。与普通人相比，那些令你最想躲藏起来或干脆死掉的时刻，就是你作为一名CEO所要经历的不同于常人的东西。”</code></li><li><code>在恰当的时机做恰当的事情、掌握事情的节奏至关重要，这是我们能够排除一切阻碍的基础。</code></li><li><code>要成为一个企业家，你需要极大的勇气、疯狂的激情和超出理性的决心，忍受反复出现的近乎死亡的体验。</code></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 传记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>管子</title>
      <link href="/posts/c4cc96a5/"/>
      <url>/posts/c4cc96a5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li><code>智者善谋，不如当时。</code><blockquote><p>顺势而为。</p></blockquote></li><li><span id="more"></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>论语</title>
      <link href="/posts/d004492e/"/>
      <url>/posts/d004492e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li><code>君子求诸己，小人求诸人。</code></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>菲利普·费舍尔</title>
      <link href="/posts/ab09d7a7/"/>
      <url>/posts/ab09d7a7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h1><p><code>专注长期持有高成长潜力的股票，重视管理层质量。</code></p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典语录</title>
      <link href="/posts/9dda3c9b/"/>
      <url>/posts/9dda3c9b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><p>魏加宁：国家之间比拼的是什么？——归根到底是体制之争，是体制效率之争。体制中最重要的是什么？——是决策机制，决策效率，看谁的决策错误少。而决策机制中最重要的是什么？——是纠错机制，能否及时纠错；而纠错机制中最重要的是什么？——是信息机制，看信息渠道是否通畅，决策者能否听到真话，能否把握真实情况。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 语录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>院长开学致辞</title>
      <link href="/posts/ea8a4fd7/"/>
      <url>/posts/ea8a4fd7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="成长的七点建议"><a href="#成长的七点建议" class="headerlink" title="成长的七点建议"></a>成长的七点建议</h1><p>一、超前思维：我在20岁时，经常问自己，假如我现在是35岁，我会这么想这么说这么做吗？如果不会，那应该怎么想怎么说怎么做？年轻是用来多走些路的，不是用来任性犯错的。</p><p>三、时间管理：每天在睡前记下自己当天完成的可圈可点的三四件事情，并括号注明你所花的分钟数。坚持21天，你的时间管理一定会突飞猛进。如果你实在没东西好写，可能只好写“与闺蜜微信聊天（180分钟）”。（大笑）这样你就知道时间去哪儿了。</p><p>四、学以致用：完善知识结构和学以致用特别重要，学而不思、思而不写，写而不用，都可能是书呆。同时，尽信书不如无书。要将逻辑思维和批判性思维进行到底。我们要敬重博导，但不要盲从博导，因为博导博导，可能一驳就倒。（笑声）当然，批判是需要逻辑和理据的，批判绝不是为批判而批判，更不是泼妇骂街。</p><span id="more"></span><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://www.sohu.com/a/338750482_100226214">厉害了！这位院长的开学致辞全程笑点无数，更深刻至极！ </a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 演讲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>庄子</title>
      <link href="/posts/8b8859e0/"/>
      <url>/posts/8b8859e0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="庖丁解牛"><a href="#庖丁解牛" class="headerlink" title="庖丁解牛"></a>庖丁解牛</h1><p>“庖丁解牛”是中国古代著名的哲学寓言，出自《庄子·养生主》。它通过一个技艺高超的屠夫解牛的故事，揭示了道家思想中顺应自然、掌握规律、以“道”驭术的深刻哲理。以下从多个角度详细解析：</p><h3 id="核心寓意解析"><a href="#核心寓意解析" class="headerlink" title="核心寓意解析"></a><strong>核心寓意解析</strong></h3><ol><li><p><strong>“道”高于“技”</strong><br>庖丁的技艺已超越单纯的技术层面，上升为对事物本质规律的把握（“道”）。他通过长期实践，掌握了牛体结构的自然规律（“天理”），因此能游刃有余。</p></li><li><p><strong>顺应自然，以无厚入有间</strong><br>刀刃之所以十九年不损，在于庖丁避开了骨骼关节的阻碍，只在筋肉缝隙间游走。比喻解决问题要避开冲突，寻找事物的空隙与规律。</p></li><li><p><strong>“目无全牛”的境界</strong><br>从“见全牛”到“未尝见全牛”，体现认知的升华：透过表象直达本质，将复杂问题分解为可操作的细节。</p></li><li><p><strong>养生与处世哲学</strong><br>文惠君从中领悟“养生”，实指道家提倡的处世之道：顺应外物规律，避免硬碰硬，减少自身损耗，达到身心自由。</p></li></ol><hr><h3 id="哲学思想延伸"><a href="#哲学思想延伸" class="headerlink" title="哲学思想延伸"></a><strong>哲学思想延伸</strong></h3><ol><li><p><strong>道家“无为”的实践体现</strong><br>并非消极不作为，而是通过透彻认知规律后，以最小的干预达成目标（如解牛时“动刀甚微”）。</p></li><li><p><strong>“技进乎道”的修炼过程</strong><br>从反复练习（技）到悟透本质（道），揭示了技能精进的普遍规律，与《卖油翁》“惟手熟尔”异曲同工，但更强调对“道”的追求。</p></li><li><p><strong>“以柔克刚”的辩证思维</strong><br>薄刃能解庞然大物，暗含道家“柔弱胜刚强”的智慧，如水般避实击虚。</p></li></ol><hr><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>林园</title>
      <link href="/posts/aa85879f/"/>
      <url>/posts/aa85879f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="投资没有别的，就是垄断，所有的风险都来源于竞争"><a href="#投资没有别的，就是垄断，所有的风险都来源于竞争" class="headerlink" title="投资没有别的，就是垄断，所有的风险都来源于竞争"></a>投资没有别的，就是垄断，所有的风险都来源于竞争</h1><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>股市心得</title>
      <link href="/posts/a696371e/"/>
      <url>/posts/a696371e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol><li>耐心的等待</li><li>独立思考</li><li>拒绝贪心<br>安全边际 –格雷厄姆<br>不要赚最后一个铜板 –李嘉诚</li></ol><h1 id="股市指标"><a href="#股市指标" class="headerlink" title="股市指标"></a>股市指标</h1><ol><li>美债收益率与市盈率倒挂：当10年期美债收益率＞标普500盈利收益率（1&#x2F;PE），警惕回调风险</li><li>纳斯达克市销率＞5时，历史回撤概率超70%</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 心得 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>李嘉诚</title>
      <link href="/posts/6a939875/"/>
      <url>/posts/6a939875/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="李嘉诚汕头大学毕业典礼演讲：愿力人生"><a href="#李嘉诚汕头大学毕业典礼演讲：愿力人生" class="headerlink" title="李嘉诚汕头大学毕业典礼演讲：愿力人生"></a>李嘉诚汕头大学毕业典礼演讲：愿力人生</h1><ol><li>一生志在千里，也知似水流年。</li><li>愚人见石，智者见泉。</li><li>愚人只知道“为” （to do） ， 智者有愿力， 把“为” （to do） 变“成为” （to be） 。</li><li>“道能弘人”肯定更舒服。</li><li>懂得“善择” 才是打造自己命运的保证。</li><li>身与物化，意到图成。</li><li>“千圣皆过影， 良知乃吾师。 ”</li></ol><p><a href="../../../file/%E6%9D%8E%E5%98%89%E8%AF%9A%E6%B1%95%E5%A4%B4%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC%E6%BC%94%E8%AE%B2%EF%BC%9A%E6%84%BF%E5%8A%9B%E4%BA%BA%E7%94%9F--%E6%95%99%E8%82%B2--%E4%BA%BA%E6%B0%91%E7%BD%91.pdf">李嘉诚汕头大学毕业典礼演讲：愿力人生–教育–人民网.pdf</a></p><span id="more"></span><h1 id="90-的时间考虑失败"><a href="#90-的时间考虑失败" class="headerlink" title="90%的时间考虑失败"></a>90%的时间考虑失败</h1><img src="/posts/6a939875/.."  alt="描述" width="500">]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>曹仁超</title>
      <link href="/posts/5fb9005d/"/>
      <url>/posts/5fb9005d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><ol><li>坚决避免股灾。</li><li>集中投资。</li><li>除非不攻击，攻击必致命。</li></ol><span id="more"></span><p><a href="../../../file/40%E5%B9%B44%E4%B8%87%E5%80%8D%EF%BC%9A%E9%A6%99%E6%B8%AF%E8%82%A1%E7%A5%9E%E6%9B%B9%E4%BB%81%E8%B6%85%E6%98%AF%E6%80%8E%E4%B9%88%E7%82%92%E8%82%A1%E7%9A%84%EF%BC%9F_%E6%89%8B%E6%9C%BA%E6%96%B0%E6%B5%AA%E7%BD%91.pdf">40年4万倍：香港股神曹仁超是怎么炒股的？_手机新浪网.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聪明的投资者</title>
      <link href="/posts/86316514/"/>
      <url>/posts/86316514/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><code>核心思想</code></h1><p><code>投资应以理性分析为基础，追求安全边际，避免情绪化决策。</code></p><h1 id="投资-vs-投机"><a href="#投资-vs-投机" class="headerlink" title="投资 vs 投机"></a><code>投资 vs 投机</code></h1><p><code>1. 投资：通过深入分析，确保本金安全，并获取合理回报。投资是可预测风险下的理性行为。</code><br><code>2. 投机：依赖市场波动和短期价格变化，追求高回报但伴随高风险。格雷厄姆认为投机不可持续。</code><br><code>3. 关键区别：投资者关注企业内在价值，投机者关注市场情绪。</code></p><h1 id="核心原则：安全边际（Margin-of-Safety）"><a href="#核心原则：安全边际（Margin-of-Safety）" class="headerlink" title="核心原则：安全边际（Margin of Safety）"></a><code>核心原则：安全边际（Margin of Safety）</code></h1><p><code>1. 定义：买入价格应显著低于企业内在价值，为潜在风险提供缓冲。</code><br>2. 实践意义：<br>降低误判风险：即使分析有误，低价买入也能减少损失。<br>抵御市场波动：价格波动对安全边际高的投资影响较小。<br><code>3. 格雷厄姆公式：股票内在价值 ≈ 企业未来盈利的折现值。</code></p><h1 id="市场先生（Mr-Market）"><a href="#市场先生（Mr-Market）" class="headerlink" title="市场先生（Mr. Market）"></a><code>市场先生（Mr. Market）</code></h1><ol><li>比喻：市场像一位情绪化的“市场先生”，每天报出不同的价格，时而乐观时而恐慌。</li><li>启示：<br><code>利用市场情绪：在价格低于价值时买入，高于价值时卖出。 避免被市场左右：投资者应独立判断，而非跟随市场波动。</code></li></ol><h1 id="常见投资错误与教训"><a href="#常见投资错误与教训" class="headerlink" title="常见投资错误与教训"></a>常见投资错误与教训</h1><ol><li>过度自信：高估自身预测市场的能力。</li><li>盲目跟风：追逐热门股票或“内幕消息”。</li><li>忽视成本：频繁交易导致佣金和税费侵蚀收益。</li><li>情绪化决策：因恐慌或贪婪偏离计划。</li></ol><h1 id="实践建议（现代适用性）"><a href="#实践建议（现代适用性）" class="headerlink" title="实践建议（现代适用性）"></a>实践建议（现代适用性）</h1><ol><li>指数基金：格雷厄姆认可指数化投资（如标普500）的长期价值。</li><li>关注企业基本面：净资产、盈利稳定性、股息记录等。</li><li>保持耐心：投资是马拉松，复利效应需要时间积累。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《聪明的投资者》强调理性、纪律和风险控制，其核心理念在当今市场依然有效。格雷厄姆的价值投资思想为巴菲特、彼得·林奇等投资大师奠定了基础，是每位投资者构建长期策略的必读经典。</p><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>格雷厄姆建议防御型投资者要遵循四大选股原则：适当分散投资10到30只股票；选股要选大型企业、杰出企业、融资保守的企业；股息持续发放20年以上；<code>市盈率不超过25倍</code>。（第5章）</li><li><code>其实价值投资就是逆向投资，在股市过于低估时买入，而在股市过于高估、安全边际太小甚至消失时卖出。</code></li><li><code>能不能克服人性的从众心理，隔绝市场巨大的情绪影响力，保持理性，这是最大的挑战。投资者最大的敌人也是他最好的朋友，就是市场。</code></li><li><strong><code>一句话概括，要想投资成功，一要智商，二要情商。智商不是聪明，而是正确的思考框架；情商不是战胜别人，而是战胜自己。</code></strong></li><li>要一生投资成功，并不需要有天才般的超高智商，也不需要神人般的非凡商业洞察力，更不需要独有你知的内幕消息。<code>要一生投资成功，只需要两个因素——有一个正确合理的思考框架让你能够做出正确的投资决策；有一种能力让你控制住自己的情绪以避免情绪破坏这个思考框架。</code></li><li>巴菲特(1993)说：“<code>透过定期投资指数基金，一个什么都不懂的投资人通常都能打败大部分专业经理人</code>，很奇怪的是，当傻钱了解到自己的极限之后，它就不再傻了。”</li><li><code>最好的投资股票方法是购买管理费很低的指数基金</code>。通过投资指数基金，在扣除管理费和其他费用之后，所获得的净收益率肯定能够超过绝大多数投资专家。</li><li>向进攻型投资者推荐以下三种投资策略：<code>第一种策略是购买相对不受市场追捧的大公司股票；第二种策略是买进被严重低估的便宜货股票；</code>第三种策略是特殊情况或“破产债务重组”股票套利。三种策略彼此有很大不同，每一种策略都要求实践者具备不同类型的知识背景和情绪性格。<br>巴菲特早期完全模仿格雷厄姆，但是<code>后来他发现，非常低估的便宜货股票后来变得很少，于是转向第一种策略，购买相对不受市场追捧的大公司股票</code>。</li><li>我们的投资仍然是集中于很少的几只股票，而且在概念上非常简单——<code>真正伟大的投资理念常常用简单的一句话就能概括。我们寻找的是一个具有持续竞争优势并且由一群既能干又全心全意为股东服务的人来管理的企业。当发现了具备这些特征的企业，而且我们又能以合理的价格购买时，我们几乎不可能出错。</code></li><li><code>要让市场服务你而不是指导你。对你有用的是市场先生的钱包，而不是市场先生的智慧。</code></li><li><code>如果你受到他的影响而追随他的一举一动，结果会是灾难性的，让你损失惨重。</code></li><li><code>如果你玩了30分钟的扑克牌游戏，还不知道谁是容易上当受骗的笨蛋，那么你就是那个笨蛋。</code></li><li>正如格雷厄姆所说：<code>市场短期是一台投票机；但长期是一台称重机。</code></li><li>巴菲特多次公开宣称：“<code>我买入股票奉行一个简单的信条—在别人贪婪时恐惧，在别人恐惧时贪婪</code>。”</li><li>巴菲特写道：“<code>我无法预测股市的短期波动，对于股市未来一个月或一年会涨会跌我一无所知。但是，很有可能，即在市场恢复信心或经济恢复之前，股市将会上涨，而且可能是大涨。因此，如果你要等到知更鸟报春，那时春天已经结束了。</code>”<blockquote><p>todo 需要分析</p></blockquote></li><li>根据我们自己长达50余年的市场经验和观察，<code>我们从来没有发现过一个依据这种“追随市场”的方法而长期获利的投资者</code>。</li><li>1.<code>某一行业显而易见的业务增长前景，并不一定会为投资者带来显而易见的利润</code>。2.即使是专家，也没有什么可靠的方法，能使其挑出前景光明的行业中最有前途的公司，并将大量的资金投入该股票。</li><li>既然任何人均可通过买入并持有一批代表性的股票，取得相当于市场平均水平的成绩，那么，<code>“超越平均水平”似乎就是一件相当容易的事情。但实际上，那些试图这么做的聪明之士的失败比率却相当高。</code></li><li>证券经纪公司所公布的股市预测结果也不能够令人满意，因为强有力的证据表明，它们精心预测出的结果，还不如简单的掷硬币方法可靠。</li><li>投资艺术具有一种并不广为人知的性质。<code>普通投资者只需付出很小的努力和具备很小的能力，就可以取得一种可靠（即便并不壮观）的成果；但是，要想提高这一可轻易获得的成果，却需要付出大量的努力和非同小可的智慧。</code></li><li>那时你将真正体会到，<code>要想成为一个聪明的投资者，重要的是性格而不是智力。</code></li><li><code>投资操作是以深入分析为基础，确保本金的安全，并获得适当的回报；不满足这些要求的操作就是投机。</code>”</li><li>根据格雷厄姆的定义，投资包括以下三个同等重要的因素：1. 在你买进一只股票之前，要对该公司及其基础业务的稳妥性进行彻底分析。2. 你必须细心地保护自己，以免遭受重大损失。<code>3. 你只能期望获得“适当的”业绩，不要期望过高。</code></li><li><code>林奇的规则—“如果利用自己的优势，投资于所熟悉的公司或产业，你就可以比专业人士做得更好”</code></li><li>哦，你也能够做到，”兰蒂斯兴奋地回答说，“<code>你惟一要做的是，盯住你熟悉的事物，保持与该行业的密切联系，并经常跟业内人士交谈</code>。”</li><li>聪明的投资者会对从这种价格大幅度变动中获利的可能性感兴趣。他面临着两种可能获利的方法：<code>择时方法和估价方法。</code></li><li>我们同样确信，<code>如果投资者以预测为基础强调择时交易，那么他最终将成为一个投机者，并要面对投机所带来的财务结果。</code></li><li>我们相信，<code>人们离华尔街越远，就会发现股市预测或择时的吹嘘越值得怀疑。投资者根本不会认真对待那些没完没了的预测结果（几乎每天都有这种预测，而且不费吹灰之力就可以获得）</code>。</li><li>似乎每个人都没有注意到<code>“择时”理念所具有的一个特点。对投机者来说，择时具有一个很重要的心理作用，因为他想迅速获取收益。</code></li><li><code>择时交易对投资者没有实际的价值，除非它恰好与估价法相吻合，</code>也就是说，除非它能使投资者按大大低于自己以前的售价重新购买到自己的股票。</li><li><code>我们确信，普通投资者不可能通过努力来成功预测股价的变动。</code></li><li><code>实际上，“聪明的投资者”的传统定义是，“那些在熊市（其他的人都在卖出时）买入，在牛市（其他的人都在买入时）卖出的人。</code>”</li><li><code>几乎所有的牛市都明显具备一些共同点，比如：(1)价格水平达到历史最高；(2)市盈率很高；(3)与债券收益相比，股息收益较低；(4)大量的保证金投机交易；(5)有许多质量较差的新普通股的发行。</code></li><li>但是，我们认为，<code>投资者的下列做法是不现实的</code>：努力将自己的策略建立在传统方法的基础上，<code>即等到出现明显的熊市价格水平时才去购买任何普通股</code>。然而，<code>我们所建议的策略考虑到了证券组合中普通股与债券比例的调整—投资者可以根据股价的高低（以价值标准来衡量）选择这样的做法。</code></li><li><code>所使用方法的广受欢迎之时，几乎也同时是这些方法的作用丧失之刻。</code></li><li>这里的教训似乎是，<code>股市上的任何赚钱方法，只要它容易理解并且被许多人采纳，那么，这种方法本身就会因太简单、太容易而无法持久。</code></li><li><code>所有美好的东西，都是既罕见又复杂的。</code>”</li><li>投资者最好是事先接受所持大多数股票价格上涨的概率—比如，今后5年内不同时期价格的上升幅度，比最低点高出50%或更多；价格的下降幅度，比最高点低等值的三分之一或更多—而不能仅仅只看到可能的情况。</li><li>正是<code>出于对人性的考虑</code>（而不是出于对财务损益的考虑），<code>我们才主张在投资者的证券组合中采用某种机械的方法，调整债券与股票之间的比重。</code>或许，这种方法的主要好处就在于，它使得投资者有事可做。 </li><li>公司过去的记录和未来前景越好，其股价与账面值之间联系越小。 </li><li>这样，我们最终面临一个悖论：<code>公司做得越成功，其股价的波动可能会越大。这实际上意味着，从根本上讲，普通股的质量越好，其投机的可能性越大。</code></li><li>这种股价暴跌，并不是表明人们对两家公司未来的长期增长产生了怀疑；相反，它反映了人们对溢价（来自于股市本身对这些企业极为看好的前景所做出的高估）缺乏足够的信心。 </li><li>如果投资者特别关注自己的股票组合的选择，那么他最好集中购买售价能较好地接近于公司有形资产价值的股票——比如，<code>高于有形资产价值的部分不超过三分之一。</code></li><li><code>股票的稳健投资并不仅仅在于购买价接近于其资产价值。除此之外，投资者还必须要求：合理的市盈率，足够强有力的财务地位，以及今后几年内的利润至少不会下降。</code></li><li>一旦投资者愿意放弃极为看好的股票（预期增长率高于平均水平的股票），他将很容易看到，有众多能满足这些标准的可供选择的股票。 </li><li>投资最广泛的股票（美国电话电报公司的股票）的实际售价，要低于其有形资产的价值</li><li>与高价（相对于收益和有形资产价值而言）购买股票的人相比，以这种账面价值为基础而建立股票组合的投资者，可以以更加独立和超然的态度来看待股市的波动。 </li><li>公众对股票的估价会出现严重的失误，过度的悲观和过度的乐观。</li><li>首先，股市经常会出现严重的错误，而且敏锐和大胆的投资者有时可以利用其明显存在的错误。 </li><li>投资者不必一直紧盯着公司的业绩，只需要时不时地对其进行细致的观察。 </li><li>从根本上讲，价格波动对真正的投资者只有一个重要意义，即当价格大幅下跌后，给投资者买入的机会，反之亦然。在除此之外的其他时间里，<code>投资者最好忘记股市的存在，更多地关注自己的股息回报和企业的经营结果。</code><br>52.<code> 市场波动对投资者之所以重要，是因为市场出现低价时，投资者会理智地做出购买决策；市场出现高价时，投资者必然会停止购买，而且还有可能做出抛售的决策。</code></li><li><code>我们并不认为，投资者非要等到市场价格最低时才去购买，因为这可能要等很长时间，很有可能造成收入损失，并且也有可能错失投资机会。</code></li><li>与看重价格波动和轻视价值基础的所有其他行为一样，经常在这一领域施展本领的一些聪明人所做的工作，会随着时间的推移而自动失效和自动失败。</li><li>他既不应该因为价格的大幅下降而担忧，也不应该因为价格的大幅上涨而兴奋。他始终要记住，市场行情给他提供了便利——要么利用市场行情，要么不去管它。他千万不要因为股价上涨而购买，或者是因为股价下跌而抛售。</li><li>股东会根据所获股息以及市场平均价格的长期趋势，判断自己的投资是否成功。这一标准应该同样可以用来检验企业管理层的效果，以及企业管理层对企业所有者的态度是否恰当。 </li><li><code>在大多数时间里，市场对许多股票的估价都是很准确的。 </code></li><li><code>股票越便宜，人们越不想购买，因为他们在仿效市场先生，而没有进行独立的思考。</code></li><li><code>资金亏损所带来的痛苦程度，是等额盈利所带来的快感程度的两倍。</code>许多人由于害怕进一步亏损而在价格接近谷底时卖出，或者是拒绝购买更多。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学</title>
      <link href="/posts/2965e54a/"/>
      <url>/posts/2965e54a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。</li></ol><p>解读：心志坚定、内心平静、安于环境、深入思考，才能最终有所收获。</p><ol start="2"><li>物有本末，事有终始。知所先后，则近道矣。</li></ol><p>解读：在生活和处事中，要抓住事物的本质，理解其发展规律，并合理安排顺序，这样才能更好地接近成功或真理。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>韩非子</title>
      <link href="/posts/55c26f29/"/>
      <url>/posts/55c26f29/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>彼得林奇</title>
      <link href="/posts/b3bd56b0/"/>
      <url>/posts/b3bd56b0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="鸡尾酒理论"><a href="#鸡尾酒理论" class="headerlink" title="鸡尾酒理论"></a>鸡尾酒理论</h1><h2 id="彼得·林奇鸡尾酒理论的四个阶段"><a href="#彼得·林奇鸡尾酒理论的四个阶段" class="headerlink" title="彼得·林奇鸡尾酒理论的四个阶段"></a><strong>彼得·林奇鸡尾酒理论的四个阶段</strong></h2><h3 id="第一阶段：市场低迷，无人谈论股票"><a href="#第一阶段：市场低迷，无人谈论股票" class="headerlink" title="第一阶段：市场低迷，无人谈论股票"></a><strong>第一阶段：市场低迷，无人谈论股票</strong></h3><ul><li><strong>特征</strong>：股市处于低位，投资者普遍对市场失去兴趣。</li><li><strong>表现</strong>：在鸡尾酒会上，当人们得知林奇是基金经理时，会迅速转移话题，甚至直接走开。</li><li><strong>投资启示</strong>：此时可能是市场底部，是长期投资者逐步建仓的好时机。</li></ul><hr><h3 id="第二阶段：市场开始反弹，少数人谈论股票"><a href="#第二阶段：市场开始反弹，少数人谈论股票" class="headerlink" title="第二阶段：市场开始反弹，少数人谈论股票"></a><strong>第二阶段：市场开始反弹，少数人谈论股票</strong></h3><ul><li><strong>特征</strong>：股市开始回升，但大多数人仍持怀疑态度。</li><li><strong>表现</strong>：人们会与林奇简短讨论股票，但更倾向于谈论风险，抱怨市场表现不佳。</li><li><strong>投资启示</strong>：市场情绪开始回暖，但仍未过热，是逐步加仓的机会。</li></ul><hr><h3 id="第三阶段：市场大幅上涨，人人都是“股神”"><a href="#第三阶段：市场大幅上涨，人人都是“股神”" class="headerlink" title="第三阶段：市场大幅上涨，人人都是“股神”"></a><strong>第三阶段：市场大幅上涨，人人都是“股神”</strong></h3><ul><li><strong>特征</strong>：股市进入牛市，投资者信心高涨。</li><li><strong>表现</strong>：人们会主动向林奇推荐股票，分享自己的“成功经验”，甚至忽视风险。</li><li><strong>投资启示</strong>：市场可能接近顶部，投资者应保持警惕，避免盲目追高。</li></ul><hr><h3 id="第四阶段：市场疯狂，股票成为唯一话题"><a href="#第四阶段：市场疯狂，股票成为唯一话题" class="headerlink" title="第四阶段：市场疯狂，股票成为唯一话题"></a><strong>第四阶段：市场疯狂，股票成为唯一话题</strong></h3><ul><li><strong>特征</strong>：市场进入狂热阶段，投机情绪盛行。</li><li><strong>表现</strong>：人们不仅推荐股票，还会告诉林奇应该买哪些股票，甚至质疑他的投资能力。</li><li><strong>投资启示</strong>：市场可能即将见顶，投资者应考虑逐步减仓，锁定利润。</li></ul><hr><h2 id="鸡尾酒理论的核心思想"><a href="#鸡尾酒理论的核心思想" class="headerlink" title="鸡尾酒理论的核心思想"></a><strong>鸡尾酒理论的核心思想</strong></h2><ol><li><strong>逆向思维</strong>：当市场情绪极度悲观时，可能是买入机会；当市场情绪极度乐观时，可能是卖出信号。</li><li><strong>情绪指标</strong>：通过观察普通投资者的行为，判断市场所处的阶段。</li><li><strong>长期投资</strong>：林奇强调，投资者应关注企业的基本面，而不是被市场情绪左右。</li></ol><hr><h2 id="应用与局限性"><a href="#应用与局限性" class="headerlink" title="应用与局限性"></a><strong>应用与局限性</strong></h2><ul><li><strong>应用</strong>：适合用于判断市场情绪周期，帮助投资者避免追涨杀跌。</li><li><strong>局限性</strong>：市场情绪的变化并不总是完全按照这四个阶段发展，且市场顶部和底部的判断需要结合其他指标。</li></ul><hr><span id="more"></span><h1 id="认知错误"><a href="#认知错误" class="headerlink" title="认知错误"></a>认知错误</h1><ol><li>都跌这么多了，不会再跌了。</li><li>都涨这么多了，不会再涨了。</li><li>已经跌到3块钱了，我还能亏多少，（可能跌到0）。</li><li>黎明前总是黑暗的，（抄底，股市没底）。</li><li>涨到10块就卖。（涨了66%应该买入，我们的思维确实卖掉）</li><li>我买的是保守股，不用但心。</li><li>没买这个股票让我亏了好多钱。 </li><li>我错过了A，我要抓住下一个A。</li><li>我买的股票涨了，所以我是对的。 </li><li>富贵险中求。</li></ol><div style="width: 1000px;"><div id="dplayer15" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer15"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/彼得林奇认知错误.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>别闹了，费曼先生</title>
      <link href="/posts/3f8e4020/"/>
      <url>/posts/3f8e4020/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>六祖坛经</title>
      <link href="/posts/5a8a6c8d/"/>
      <url>/posts/5a8a6c8d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><h1 id="顿悟成佛的思想"><a href="#顿悟成佛的思想" class="headerlink" title="顿悟成佛的思想"></a>顿悟成佛的思想</h1><p>惠能大师强调“顿悟”，认为众生皆有佛性，成佛并非遥不可及，关键在于能否顿悟自性。他提出“菩提本无树，明镜亦非台，本来无一物，何处惹尘埃”的著名偈语，揭示了禅宗的核心思想：佛性本自具足，无需外求。这种思想打破了传统佛教的繁琐修持，提倡直指人心、见性成佛。</p><h1 id="不立文字，教外别传"><a href="#不立文字，教外别传" class="headerlink" title="不立文字，教外别传"></a>不立文字，教外别传</h1><p>禅宗主张“不立文字”，认为佛法真谛无法通过语言文字完全传达，而是要靠心传心、以心印心。惠能大师虽不识字，却能通过内心的领悟直达佛法的精髓。这种思想提醒我们，真正的智慧往往超越语言和逻辑，需要在实践中体悟。</p><h1 id="平常心是道"><a href="#平常心是道" class="headerlink" title="平常心是道"></a>平常心是道</h1><p>惠能大师提倡“平常心是道”，认为修行不必拘泥于形式，日常生活中的一举一动皆是修行的机会。无论是吃饭、睡觉，还是劳作，只要心无杂念，便是修行。这种思想让佛法更加贴近生活，打破了修行与世俗生活的界限。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>段永平投资问答录（投资逻辑篇）</title>
      <link href="/posts/ae28fa81/"/>
      <url>/posts/ae28fa81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="投资理念"><a href="#投资理念" class="headerlink" title="投资理念"></a>投资理念</h1><p><strong>段永平：我理解的投资归纳起来就是：买股票就是买公司，买公司就是买公司的未来现金流折现，句号！</strong></p><h2 id="Stop-doing-list（不为清单）"><a href="#Stop-doing-list（不为清单）" class="headerlink" title="Stop doing list（不为清单）"></a>Stop doing list（不为清单）</h2><ol><li>不做空</li><li>不用margin（融资，保证金杠杆交易）</li><li>不做不懂的东西</li><li>不盲目扩大自己的能力圈</li><li>不频繁决策（less is more少即是多）</li><li>不做短期的投机</li><li>对有负债的公司不太愿意重仓</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-07日记</title>
      <link href="/posts/734b1c73/"/>
      <url>/posts/734b1c73/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="332201330cce88221c945667c12514918537aeebc826251825d02e66f16bc213">026422d16125c0ef5486e4aca3c5daf506eac8b704d20a3e10d8dbe17b8641d586f098f2562ff378c8eaefc40cd08645fcb781c0c27175247887a8fa63710904c5fb41cc2077160fcb551c7176b562e7f0b1d3a29e848d56e354e3210cfad118b2029c1e8a692a35b614a0c9f658fa58fea90d31e7290f42931238ec4b8ecacbf28732c97ffd1f634c82720f065aa369dda264374aa10d648358b07e415b465fa735ba3ad5f3c0dcb85a1da85c1629e757cf15c3aa70d7f2ede01d21306263745580f3ddb8adfdad4df15f8cd5a62dabfdad4570d5d7b39f52634fea8c139dc7ba71d47d5661009f53d769e4859fe2111150475be9705e7a4cbb6e95be74ba97121a8716b2b49bf9057bf0eade751c37c2236339dcbeec47a556674d64577988970559254e8e8d86c64c01821d9b50201e1ce7a0c1c4e63060cc5e12eba549be64f58f3f0cd8fe3225f8540c58375f6fb7cddcc77483f7b3ec14b21d4e3f8fecf510dcde50b7a6a0212f08f301ff3bc7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彼得·林奇的成功投资</title>
      <link href="/posts/5294b1e1/"/>
      <url>/posts/5294b1e1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li><p>用心观察生活，从中发现投资的线索，也是林奇书中多次提到的投资方法。无论是衣服还是袜子，无论是玩具还是食品，总之，最佳的投资对象很可能就出现在你的旅途中、在陪家人浏览的商店里。必须承认，这种<code>热爱生活</code>的投资法对我影响至深，直至今日，我挑选投资对象的标准之一就是<code>在生活中可以遇见该公司的产品或服务</code>。当年我抓住投资生涯中的第一只10倍股——长虹，也是受到了林奇这个观点的启示。</p></li><li><p>鸡尾酒会理论.</p><p> 彼得·林奇使用<code>鸡尾酒会理论</code>作为一种市场情绪的温度计，帮助他判断市场的过热或低迷状态。虽然这一理论并不具备科学严谨性，但它反映了市场情绪在投资决策中的重要性：</p><ul><li><strong>冷漠阶段</strong>：可能是买入的好时机，因为市场低迷，股票价格较低。</li><li><strong>兴趣阶段</strong>：表明市场复苏，情绪改善，但要注意选择优质股票。</li><li><strong>狂热阶段</strong>：提示市场可能过热，投资者应审慎，可能考虑卖出或减少头寸。</li></ul></li></ol><span id="more"></span><ol start="3"><li>推动标准普尔500指数上涨的主要动力是一些大盘股大幅上涨，而不是小盘股和中盘股。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>沉思录</title>
      <link href="/posts/668e4635/"/>
      <url>/posts/668e4635/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>我们听到的一切都只是一个观点，而不是事实。 </li><li>我们看见的一切都只是一个视角，而不是真相。 </li><li>让我们摇摆不定的不是事物本身，而是我们内心的恐惧与希望。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>马克·安德森</title>
      <link href="/posts/64d45926/"/>
      <url>/posts/64d45926/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>我这辈子最享受的浪费时间的方式就是研究各种提高效率的方法。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>孔子</title>
      <link href="/posts/95145ed/"/>
      <url>/posts/95145ed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>学而不思则罔，思而不学则殆。</li></ol><span id="more"></span><p>孔子本人就是学思结合的典范。据司马迁《史记·孔子世家》记载：孔子跟师襄子学弹琴，十日不停。师襄子说：”可以学新曲子了。”孔子回答说：”我只是学会了弹这首曲子，还没掌握该曲的技法呢。”又过了几天，师襄子说：”你已经掌握曲子的技法了，可以学新曲子了。”孔子答道：”我还没领悟曲子的神韵呢。”几天后，师襄子再劝：”你已经能很好领悟曲子的神韵了，换首新曲子学吧。”孔子仍说：”我还没参透作曲人的人品。”又过了一段时间，孔子神情俨然，仿佛进到新的境界：时而神情庄重穆然，若有所思，时而怡然高望，志意深远。孔子说：”我知道他是谁了：那人皮肤深黑，体形颀长，目光远大，像统治四方诸侯的王者，除了周文王谁能作此乐曲！”师襄子听了非常吃惊，向孔子行了个礼说：”没错！我的老师说过这首曲子名叫《文王操》！”孔子学琴的故事充分体现了日学日思、学思并重的治学态度。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>思考</title>
      <link href="/posts/67d01b1e/"/>
      <url>/posts/67d01b1e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="什么是优秀的企业"><a href="#什么是优秀的企业" class="headerlink" title="什么是优秀的企业"></a>什么是优秀的企业</h2><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>韩非子</title>
      <link href="/posts/55c26f29/"/>
      <url>/posts/55c26f29/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>慎易以避难 敬细以远大。<br>谨慎对待容易的事情，就能避免困难；认真对待细微的事情，就能成就大事业。</li><li></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>邱国鹭</title>
      <link href="/posts/d394ce51/"/>
      <url>/posts/d394ce51/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>在投资分析中，简单的往往是实用的：在好行业中挑选好公司，然后等待好价格出现时买入。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>段永平</title>
      <link href="/posts/a2f50a04/"/>
      <url>/posts/a2f50a04/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li><code>理性就是想长远。</code></li><li><code>人们关注我们往往是因为我们做了的那些事情， 其实我们之所以成为我们，很大程度上还因为我们不做的那些事情。</code></li><li><code>我理解的投资归纳起来就是：买股票就是买公司，买公司就是买公司的未来现金流折现。</code></li><li><code>聪明人知道如何把事情做对，但有智慧指的是要做对的事情。</code></li><li><code>勤奋和天赋其实都没那么重要，做对的事情最重要。</code></li><li><code>没人可以保证自己只做对的事情，所以需要建立stop doing list。</code></li><li><code>赌一般指的是48%赢面的下注，90%以上赢面的下注我一般称之为投资。</code></li><li><code>做时间站在你一边的事情。五年十年二十年后，你会知道其中的区别的。</code></li><li><code>我的目标不是从此不抽烟，而是今天不抽烟。把目标变小，胸无大志。只要你在做正确的事的道路上，每天做对一次，就会离目标更近一些。</code></li><li><code>为什么很多人说明知是错的，他还要继续做呢？因为错的事情往往有短期的诱惑。</code></li><li>学校主要教的是你的学习能力。当你对某件事有兴趣的时候，就不会对未来的东西感到恐惧。</li><li><code>人生最大的成功，是做一个有目标的人。所有的快乐就在于实现这个目标，而不是得到一个结果。</code></li><li><code>错误是不可避免的，但呆在能力圈内以及专注和用功，可以大幅度减少犯错的机会。</code></li><li><code> 心态是最重要的。在你无法超越别人的时候，你只能先超越自己，哪怕是超越自己狭隘的自尊心。</code></li><li><code>投资做得好的人都很慢。大家并不在乎失去一些机会，但是最重要的是你不要去踩雷。</code></li><li><code>当你迷惘的时候，试试往远处看？看10年，往往比看1-2年要容易很多，看一两年，会比看一两天容易很多。</code></li></ol><h1 id="段永平-好的商业模式不会低毛利"><a href="#段永平-好的商业模式不会低毛利" class="headerlink" title="段永平:好的商业模式不会低毛利!"></a>段永平:好的商业模式不会低毛利!</h1><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/段永平好的商业模式不会低毛利.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><span id="more"></span><h1 id="段永平2025年浙江大学演讲全文（万字实录）"><a href="#段永平2025年浙江大学演讲全文（万字实录）" class="headerlink" title="段永平2025年浙江大学演讲全文（万字实录）"></a>段永平2025年浙江大学演讲全文（万字实录）</h1><ol><li>我觉得最主要的是，不论你是在学习方法还是创业上，<code>每一个决策不能仅着眼于当下，而应该考虑到五年、十年甚至二十年后的影响。我的回答可能适用于许多问题，我们需要有长远的眼光。</code></li><li><code>这可能正是你缺钱的原因，因为一直想着快速赚钱。</code></li><li><code>好赛道是不会进入低毛利的，低毛利的都是商业模式比较差、产品差异化很小的产品。</code></li><li>我没有什么批判性思维。我就是想，我本质想，<code>想长远，想本质。</code></li><li>你做事情要尽量想长远。不要让重要的事情变成紧急的事情，我觉得这很重要。</li><li>最重要的三点，<code>一是做对的事情，把事情做对</code>，发现错了及时改，不管付出多少代价都是最小的代价；二是<code>“胸无大志”、不急功近利</code>；三是要<code>有是非，要正直，要对得起未来。</code></li></ol><div style="width: 360px;"><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/段永平-浙大.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>段永平的62条思考：所有的优秀，都是熬出来的</p>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>史玉柱</title>
      <link href="/posts/d94f7c50/"/>
      <url>/posts/d94f7c50/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>1.该公司未来盈利能否持续理想成长？2.眼前股价被低估没？只要同时满足这两条就买入，买完，该干嘛就干嘛去。看不懂的行业，我不买；15倍以上市盈率的，我不买。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查理芒格</title>
      <link href="/posts/9445d4d4/"/>
      <url>/posts/9445d4d4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h1><p><code>长期持有护城河深厚的伟大企业。</code></p><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li><code>心静如水才是交易者最大的武器，因为市场上的钱都是从浮躁者流向内心安静的人兜里。</code></li><li>值得注意的是，像我们这样的人，<code>通过努力保持不犯蠢（而不是努力变得非常聪明），就能获得很多长期优势。</code></li><li>本·格雷厄姆有一些盲点，他过低估计事实，而那些事实值得花大本钱投入。</li><li><code>穷人对赚钱的误解，就是一直学习，不断追求知识而忽视行动，可能是阻碍他们致富的最大障碍。</code></li><li><code>“学习新知识会触发多巴胺释放，给人一种进步和成就感，”芒格解释道，“而采取实际行动则充满不确定性和可能的失败风险。从心理激励的角度看，持续学习比开始行动更&#39;有吸引力&#39;。</code></li><li><code>“这就像一个人不断学习如何使用锤子、螺丝刀和扳手，却从不实际建造任何东西，芒格打了一个形象的比喻，“他可能成为工具使用的专家，但永远不会成为一名建筑师或工程师。”</code></li><li><code>希望在100%确定的情况下才行动，但在现实世界中，这种确定性几乎不存在。</code><blockquote><p>股市应该避免贪心</p></blockquote></li><li><span id="more"></span></li></ol><ul><li><strong>格雷厄姆过低估计了一些事实的重要性。</strong> 这些事实可能包括：<ul><li><strong>企业的竞争优势：</strong> 格雷厄姆更关注财务数据，而较少关注企业的竞争优势。他认为，只要企业有足够的价值，即使没有竞争优势，也能获得不错的回报。但实际上，拥有强大的竞争优势的企业，更容易在长期内取得成功。</li><li><strong>管理层的质量：</strong> 格雷厄姆认为，只要企业有足够的价值，管理层的质量并不重要。但实际上，优秀的管理层能够创造更大的价值，而糟糕的管理层则会毁掉一个企业。</li><li><strong>未来增长潜力：</strong> 格雷厄姆更关注企业的历史数据，而较少关注企业的未来增长潜力。他认为，只要企业有足够的价值，即使没有增长潜力，也能获得不错的回报。但实际上，拥有巨大增长潜力的企业，更容易获得更高的回报。</li></ul></li><li><strong>这些被低估的事实值得花大本钱投入。</strong> 也就是说，如果你发现了这些被格雷厄姆低估的事实，并且认为它们对企业未来发展至关重要，那么你应该敢于下重注，即使这与格雷厄姆的传统价值投资理念有所不同。</li></ul><ol start="4"><li>分散投资只会令自己分身不暇，宜重锤出击，集中火力专攻少数优质企业，创富路上便能一本万利。</li><li>人们低估了那些简单大道理的重要性，但这些道理才是取得成功的关键。 伯克夏·哈撒韦就是一个很好的例子，它证明了这些简单道理的强大力量。 伯克夏·哈撒韦的成功，并非源于复杂的策略，而是源于其对简单道理的坚持。</li><li>以合理的价格，购买非常优秀公司的股票；而不是以超低的价格，购买平庸公司的股票。</li><li><code>在有鱼的地方钓鱼。</code></li></ol><h1 id="逆向思维"><a href="#逆向思维" class="headerlink" title="逆向思维"></a>逆向思维</h1><div style="width: 360px;"><div id="dplayer16" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer16"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/发现更多精彩视频 - 抖音搜索_3.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毛泽东</title>
      <link href="/posts/32aba496/"/>
      <url>/posts/32aba496/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>黄奇帆</title>
      <link href="/posts/8e7723b5/"/>
      <url>/posts/8e7723b5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>黄奇帆认为，今后二三十年能够形成万亿美元级别的五大件，大体上包括以下五种，<code>一是无人驾驶的新能源汽车，二是家用机器人，三是头戴式AR、VR的眼镜和头盔，四是柔性显示，五是3D打印设备。</code>他表示，要积极进行前瞻性的布局和主动出击，围绕这些重点产业，形成一批具有全球竞争力的产业链集群。</li></ol><div style="width: 360px;"><div id="dplayer9" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer9"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/发现更多精彩视频 - 抖音搜索.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>丘吉尔</title>
      <link href="/posts/e3b78e3e/"/>
      <url>/posts/e3b78e3e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>你能看到多远的过去，就能看到多远的未来。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>张一鸣</title>
      <link href="/posts/d591513b/"/>
      <url>/posts/d591513b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>延迟满足感程度在不同量级的人是没法有效讨论问题的，因为他们愿意触探停留的深度不一样。</li><li>保证足够睡眠是积极高效的第一步。</li><li></li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爱因斯坦</title>
      <link href="/posts/710e6405/"/>
      <url>/posts/710e6405/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>凡事都应该弄得愈简单愈好，但是别把它简化了。<br>everything should be made as simple as possible, but no simpler。</li><li><span id="more"></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任正非</title>
      <link href="/posts/4a22a18a/"/>
      <url>/posts/4a22a18a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>投资未来，聚焦未来。</li></ol><div style="width: 360px;"><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/华为要投资未来.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><span id="more"></span><ol start="2"><li>最小切口,力出一孔,饱和攻击.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>苏姿丰</title>
      <link href="/posts/9fe14cf1/"/>
      <url>/posts/9fe14cf1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>迎难而上，真正能够产生深远影响的，往往是哪些充满挑战与困难的问题。</li></ol><span id="more"></span><div style="width: 360px;"><div id="dplayer5" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer5"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_9.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿基米德</title>
      <link href="/posts/198f111c/"/>
      <url>/posts/198f111c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>给我一个支点，我可以撬动地球。</li></ol><p>哲学思考:暗示了人类智慧的力量。只要找到正确的方法和角度,就能解决看似不可能的问题。<br>比喻意义:在日常生活中,这句话常被用来比喻只要找到关键点,就能解决复杂的问题或实现远大的目标。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王阳明</title>
      <link href="/posts/b5f314a4/"/>
      <url>/posts/b5f314a4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>凡事向外求十年如一日，凡事向内求日日如新生。</li><li><span id="more"></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格雷厄姆</title>
      <link href="/posts/d8b7e47f/"/>
      <url>/posts/d8b7e47f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h1><p><code>低价买入低估资产，注重安全边际。</code></p><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>投资并不是要在别人的游戏中战胜别人,而是在自己的游戏中控制自己.</li><li>牛市是普通投资者亏损的主要原因.</li><li>内在价值是价值投资的前提。</li><li>股市从短期来看是投票机，从长期来看则是称重机。</li><li>安全边际：以四毛的价格买值一元的股票，保留有相当大的折扣，从而类减低风险。</li><li>基金经理强于普通投资者，但不强于指数。</li><li>定投产品比较理想的是指数基金，包括股指和组合。</li><li>在大家恐惧时贪婪，在大家贪婪时恐惧。行不行？这个策略的问题是熊市无底，牛市无顶。</li><li>不管多么小心，你无法不犯错误，只能恪守安全边际，也就是说，不管股票多么来劲绝不高买，你才能控制住犯错的后果。</li><li>任何超过40倍PE的股票都是有风险的，无论它有多高的成长!</li><li>永远不要因为股票上涨而买进，也不要因为股票下跌而卖出。</li><li>在牛市时很难见到上市公司手持现金超过股价，但熊市时这种机会比想象的要多，要抓住。</li></ol><span id="more"></span><h1 id="聪明的投资者"><a href="#聪明的投资者" class="headerlink" title="聪明的投资者"></a>聪明的投资者</h1><ol><li>长期以来，有一种流传甚广的观点认为：成功的投资技巧首先在于找出未来最有可能增长的行业，然后再找出其中最有前途的公司。例如，精明的投资者或其精明的顾问很早就会发现整个计算机行业，尤其是IBM公司，巨大的增长潜力。</li></ol><h2 id="投资和投机"><a href="#投资和投机" class="headerlink" title="投资和投机"></a>投资和投机</h2><ol><li>投资就是以深入分析为基础，确保本金的安全，并获得适当的回报。 而投机则是完全试图从市场价格波动中牟利。</li></ol><table><thead><tr><th>特征</th><th>投资</th><th>投机</th></tr></thead><tbody><tr><td>目标</td><td>获取企业的未来收益</td><td>利用价格波动获取短期利润</td></tr><tr><td>时间周期</td><td>长期持有</td><td>短期交易</td></tr><tr><td>风险</td><td>较低</td><td>较高</td></tr><tr><td>分析方法</td><td>理性分析</td><td>情绪驱动</td></tr></tbody></table><h2 id="股价的意义"><a href="#股价的意义" class="headerlink" title="股价的意义"></a>股价的意义</h2><ol><li>从根本上讲，价格波动对真正的投资者只有一个重要的意义：当价格大幅下跌后，提供给投资者购买机会；当价格大幅上涨后，提供给投资者出售机会。而其他时候，他如果忘记股票市场而把注意力放在股息收入和公司运作状况上，将会做得更好。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>宗馥莉</title>
      <link href="/posts/210cab14/"/>
      <url>/posts/210cab14/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>经营企业最重要的是要保持一件事情有价值地持续地做下去，如果把目光放到未来3年，同台竞技的人有很多；但如果把目光放到未来10年、20年，那么竞争者就所剩不多。视野越长远，步伐越坚定。长青企业往往是坚定的长期主义者，他们能超越时代，超越变化，这就是<code>慢即是快</code>的道理。</li></ol><div style="width: 360px;"><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_7.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>黄光裕</title>
      <link href="/posts/8a396295/"/>
      <url>/posts/8a396295/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>善于运用，善于整合。<span id="more"></span></li></ol><div id="dplayer8" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer8"),"autoplay":true,"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_6.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>雷军</title>
      <link href="/posts/3d7ec81/"/>
      <url>/posts/3d7ec81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>雷军认为，小米SU7成功本质上是小米模式的成功，是小米方法论的成功，归根结底是小米文化价值观的成功。</li><li><code>所有的成功都是运气，如果你不重视机会的话，你其实很难大成，顺势而为，1%的灵感要超过99%的汗水。</code></li><li><code> 第一，要定个高的目标；第二，把它分解成一个一个可实现的目标；第三，热爱才是把所有事情做好的前提，</code>要真的懂那件事情、爱那件事情，才能把那件事情做好。</li><li><code>我们一定要把所有成功或者失败给它拆解清楚，我们成，成在什么地方；我们输，输在什么地方。在小米内部，有非常强的复盘文化。</code>复盘是围棋术语，最核心的就是：<br>我们到底干对了什么？我们干错了什么？假如重干，我们应该怎么干？其实大家做每件事情都可以用这个方法去想一想。</li></ol><h1 id="重视机遇"><a href="#重视机遇" class="headerlink" title="重视机遇"></a>重视机遇</h1><div style="width: 360px;"><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/1的灵感要超过99的汗水.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><span id="more"></span><h1 id="思考失败更多，考虑足够的风险。"><a href="#思考失败更多，考虑足够的风险。" class="headerlink" title="思考失败更多，考虑足够的风险。"></a>思考失败更多，考虑足够的风险。</h1><div style="width: 360px;"><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/雷军思考失败.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>马云</title>
      <link href="/posts/cdca2d2f/"/>
      <url>/posts/cdca2d2f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王立群</title>
      <link href="/posts/5a8a6c8d/"/>
      <url>/posts/5a8a6c8d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>人生的悲剧,往往是从自我的失衡开始。命运的阴霾，它是始于内心的乌云。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>丘成桐</title>
      <link href="/posts/5a8a6c8d/"/>
      <url>/posts/5a8a6c8d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>乔布斯</title>
      <link href="/posts/622b42c/"/>
      <url>/posts/622b42c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>艺术与科学,理论与实践.</li><li>把想法变成现实的，才是真正思考过这个想法的。</li><li>思想家和实干家。知行合一。</li><li><code>如果你现在还没有找到喜欢什么，那么就继续找、不要停下来、全心全意地去找，当你找到的时候你就会知道的。就像任何真诚的关系，历久弥新。所以继续找，直到你找到它，不要停止！</code></li><li><code>如果你把每一天都当作生命中最后一天去生活的话，那么总有一天你会发现自己是正确的。</code></li><li><code>“记住你即将死去”是我一生中遇到的最重要箴言。它帮我指明了生命中重要的选择。因为几乎所有的事情，包括所有的荣誉、所有的骄傲、所有对难堪和失败的恐惧，这些在死亡面前都会消失。我看到的是留下的真正重要的东西。</code></li><li><code>Stay Hungry, Stay Foolish。</code></li></ol><span id="more"></span><div style="width: 360px;"><div id="dplayer2" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer2"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_3.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><p>4.<br>向那些疯狂的家伙们致敬，<br>他们特立独行，<br>他们桀骜不驯，<br>他们惹是生非，<br>他们格格不入，<br>他们用与众不同的眼光看待事物，<br>他们不喜欢墨守成规，<br>他们也不愿安于现状。<br>你可以认同他们反对他们<br>颂扬或是诋毁他们，<br>唯独不能漠视他们。<br>因为他们改变了寻常的事物。<br>推动了人类向前迈进<br>或许他们是别人眼里的疯子，<br>但他们却是我们眼中的天才。<br>因为只有那些疯狂到以为自己能够改变世界的人，<br>才能真正的改变世界。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>巴菲特</title>
      <link href="/posts/142ab2b5/"/>
      <url>/posts/142ab2b5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>巴菲特之所以伟大不在于他在75岁拥有450亿美金的财富，而在于他在很年轻的时候想明白很多道理，用一生的岁月来坚守。</p><h1 id="伟大的企业-Deepseek"><a href="#伟大的企业-Deepseek" class="headerlink" title="伟大的企业 - Deepseek"></a>伟大的企业 - Deepseek</h1><p>巴菲特对伟大企业的定义主要包括以下几个方面：</p><ol><li><p><strong>持久的竞争优势</strong><br>伟大企业拥有强大的经济护城河，能够长期抵御竞争，保持高利润。这种优势可以来自品牌、成本控制、规模效应或技术壁垒等。</p></li><li><p><strong>优秀的管理层</strong><br>管理层应具备诚信、能力和为股东利益着想的品质，能够有效配置资本，推动企业长期增长。</p></li><li><p><strong>清晰的商业模式</strong><br>企业的业务模式应简单易懂，具有可预测的现金流和盈利前景，避免复杂或难以理解的行业。</p></li><li><p><strong>高资本回报率</strong><br>伟大企业应能持续产生高资本回报率（如ROE、ROIC），并在不需要大量资本投入的情况下实现增长。</p></li><li><p><strong>长期增长潜力</strong><br>企业应具备长期增长的能力，能够通过扩展市场、创新或提升效率来持续创造价值。</p></li><li><p><strong>合理的估值</strong><br>即使企业具备上述特质，也需以合理的价格买入，确保投资的安全边际。</p></li></ol><p>总结来说，巴菲特认为伟大企业应具备持久的竞争优势、优秀的管理层、清晰的商业模式、高资本回报率、长期增长潜力，并且估值合理。</p><h1 id="1998年佛罗里达大学演讲"><a href="#1998年佛罗里达大学演讲" class="headerlink" title="1998年佛罗里达大学演讲"></a>1998年佛罗里达大学演讲</h1><ol><li>习惯的枷锁，开始的时候轻的难以察觉，到后来却重的无法摆脱。</li></ol><h2 id="聪明人为什么会做傻事"><a href="#聪明人为什么会做傻事" class="headerlink" title="聪明人为什么会做傻事"></a>聪明人为什么会做傻事</h2><ol><li>为了赚自己不需要的钱，把自己手里的钱把自己需要的钱都搭进去了，这不是傻是什么绝对是傻，不管智商不高都是傻。<strong>为了得到对自己不重要的东西。甘愿拿对自己重要的东西去冒险，哪能这么干，</strong>我不管成功的概率多少还是1000:1, 我都不做这样的事，假如你给我一把枪，里面有1000个子弹，或者说是100万个子弹，只要有一个子弹是真的对着太阳穴打，你给我多少钱我都不会开枪的。要是我赢了，我不需要那些钱，又是我输了，结果不用说了，这样的事我一点都不做，</li><li>一生只富一次<span id="more"></span></li></ol><h2 id="精彩解析"><a href="#精彩解析" class="headerlink" title="精彩解析"></a>精彩解析</h2><div style="width: 360px;"><div id="dplayer10" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer10"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/bafeite.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><h1 id="巴菲特给年轻人的5个人建议"><a href="#巴菲特给年轻人的5个人建议" class="headerlink" title="巴菲特给年轻人的5个人建议"></a>巴菲特给年轻人的5个人建议</h1><ol><li>最好的投资就是投资自己。</li><li>爱护自己的身体。</li><li>向上社交,选择与比你优秀的人为伍。</li><li>投资而不要投机，投资最好长期持有，变动在投资中是不明智的。</li><li>兴趣最重要。</li></ol><div style="width: 360px;"><div id="dplayer11" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer11"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_8.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>投资股票的第一原则：不要赔钱；第二原则：永远不要忘记第一原则。</li><li>短期来看股票市场是投票机，但长期来看它更像是称重机。</li><li>只有退潮时，你才知道谁在裸泳。</li><li>任何情况都不会驱使我做出在能力圈范围以外的投资决策。</li><li>在别人恐惧时我贪婪，在别人贪婪时我恐惧。</li><li>开始存钱并及早投资，这是最值得养成的好习惯。</li><li>要一生投资成功，并不需要有天才般的超高智商，也不需要神人般的非凡商业洞察力，更不需要独有你知的内幕消息。要一生投资成功，只需要两个因素——有一个正确合理的思考框架让你能够做出正确的投资决策；有一种能力让你控制住自己的情绪以避免情绪破坏这个思考框架。–&lt;聪明的投资者&gt;</li><li>如果一个投资者对任何行业和企业都一无所知的话，但对美国整体经济前景很有信心，并且如果愿意长期投资的话，那么你应该广泛的分散化投资，你应该分散持有大量不同的公司股份，并且分期分批次购买。<code>最简单的方法就是通过定期投资指数基金</code>，一个什么都不懂的业余投资者竟然往往能够战胜大部分专业投资者。</li><li>时间是优秀企业的朋友，是平庸企业的敌人。</li></ol><div id="dplayer12" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer12"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/《成为沃伦·巴菲特》中的投资原则-网易公开课.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h1 id="20个打孔原则"><a href="#20个打孔原则" class="headerlink" title="20个打孔原则"></a>20个打孔原则</h1><ol><li>一定要在最好的投资上下重注。其他时间则按兵不动。</li></ol><div style="width: 360px;"><div id="dplayer13" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer13"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/发现更多精彩视频 - 抖音搜索_2.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div><h1 id="从事投资不需要多高的智商，你需要的是维持稳定的情绪以及独立思考的能力"><a href="#从事投资不需要多高的智商，你需要的是维持稳定的情绪以及独立思考的能力" class="headerlink" title="从事投资不需要多高的智商，你需要的是维持稳定的情绪以及独立思考的能力"></a>从事投资不需要多高的智商，你需要的是维持稳定的情绪以及独立思考的能力</h1><div style="width: 360px;"><div id="dplayer14" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer14"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/巴菲特从事投资不需要多高的智商你需要的是维持稳定的情绪以及独立思考的能力.mkv"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
          <category> 金融人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王兴</title>
      <link href="/posts/abdcbc80/"/>
      <url>/posts/abdcbc80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>有的信息一天之后就是垃圾，有的信息一周之后就是垃圾，有的信息一年之后就是垃圾，<code>只有少数信息是你一辈子都能用上的。年轻时把时间花在哪类信息上，对人生道路会有直接影响。</code></li><li>“<code>大多数人以为战争是由拼搏组成的，其实不是，是由等待和熬煎组成的</code>……” 说这话的大哥当年参加过战争，后来创业，现在做投资。</li><li><code> 据沈红杉的投资原则是 “Bet on the racetrack, not the jockey”，直译过来就是“赌赛道，不赌赛手”，但我更喜欢孙子的话“求之于势，不责于人”</code></li><li><code>我不喜欢持续做大量的决定，我更喜欢的是接收大量信息，然 后做几个大的决定。</code></li><li><code>每天最当其冲的工作，不是决定某件事该怎么处理，而是决定哪些事要尽快处理、哪些事暂不处理了。</code></li><li></li></ol><span id="more"></span><div id="dplayer3" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer3"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/有所思的抖音 - 抖音_2.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h1 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h1><div style="width: 360px;"><div id="dplayer4" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer4"),"theme":"#FADFA3","loop":true,"lang":"zh-cn//语言","screenshot":true,"hotkey":true,"preload":"auto","volume":0.9,"video":{"url":"/video/陆向谦实验室赵老师的抖音 - 抖音.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script></div>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>盐铁论</title>
      <link href="/posts/6bb5aa2e/"/>
      <url>/posts/6bb5aa2e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="经典语录"><a href="#经典语录" class="headerlink" title="经典语录"></a>经典语录</h1><ol><li>明者因时而变，知者随世而制。</li></ol><p>语出汉·桓宽《盐铁论·忧边》。聪明的人会随着时间的变化而变化，有智慧的人，会按照世事变化而改变策略。这句话指出了变革的重要性和必要性，要求与时俱进，反对因循守旧，主张根据时。</p><ol start="2"><li>国有贤士而不用，非士之过，有国者之耻。</li></ol><p>语出汉·桓宽《盐铁论·国病》。这句话强调了国家有贤人而不得用是一国之君在任人方面的失误。“有国者”指的就是国君。这句话的意思是说，一国之内若是有贤能之士而不得重用的话，并不是这个贤人的过错，而是掌握国家权力之人的耻辱。</p><ol start="3"><li>善为政者，弊则补之，决则塞之。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>孙子兵法</title>
      <link href="/posts/f5549be7/"/>
      <url>/posts/f5549be7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><ul><li><strong>谋定而后动：</strong> 谋略是战争的根本，要先做好充分的准备，制定周密的计划，才能取得胜利。</li><li><strong>知己知彼，百战不殆：</strong> 要了解自己和敌人的情况，才能制定有效的作战策略。</li><li><strong>虚实相生：</strong> 要善于运用虚实之势，迷惑敌人，取得主动权。</li><li><strong>攻其不备，出其不意：</strong> 要抓住敌人的弱点，出其不意地发动攻击。</li><li><strong>因敌制胜：</strong> 要根据敌人的情况，灵活地调整作战策略，才能取得胜利。</li></ul><span id="more"></span><h1 id="始计第一"><a href="#始计第一" class="headerlink" title="始计第一"></a>始计第一</h1><h2 id="战争中的欺诈和迷惑战术："><a href="#战争中的欺诈和迷惑战术：" class="headerlink" title="战争中的欺诈和迷惑战术："></a><strong>战争中的欺诈和迷惑战术：</strong></h2><ul><li><p><strong>兵者，诡道也。故能而示之不能，用而示之不用，近而示之远，远而示之近。利而诱之，乱而取之，实而备之，强而避之，怒而挠之，卑而骄之，佚而劳之，亲而离之，攻其无备，出其不意。此兵家之胜，不可先传也。</strong></p></li><li><p>战争是充满欺诈的，要善于隐藏自己的真实实力，迷惑敌人，出其不意地发动攻击。</p></li></ul><h2 id="事先谋划的重要性："><a href="#事先谋划的重要性：" class="headerlink" title="事先谋划的重要性："></a><strong>事先谋划的重要性：</strong></h2><ul><li><p><strong>夫未战而庙算胜者，得算多也；未战而庙算不胜者，得算少也。多算胜少算，而况于无算乎！吾以此观之，胜负见矣。</strong></p></li><li><p>战争要事先做好充分的准备，制定周密的计划，才能取得胜利。</p></li></ul><h1 id="作战第二"><a href="#作战第二" class="headerlink" title="作战第二"></a>作战第二</h1><ul><li><p><strong>故兵贵胜，不贵久。</strong></p></li><li><p>战争贵在取胜，不在于持久。</p></li></ul><h1 id="谋攻第三"><a href="#谋攻第三" class="headerlink" title="谋攻第三"></a>谋攻第三</h1><ul><li><strong>不战而屈人之兵是最高策略：</strong> 孙子认为，战争是最后的手段，最好的策略是通过谋略和外交手段使敌人屈服，避免战争的发生。</li><li><strong>伐谋是最高层次的用兵策略：</strong> 孙子将用兵策略分为四个层次：伐谋、伐交、伐兵、攻城，其中伐谋是最重要的，即通过策略和计谋使敌人主动投降。</li><li><strong>知己知彼是取胜的关键：</strong> 孙子认为，战争的胜负取决于对敌我双方的了解和对形势的判断。他提出了五点取胜之道：知己知彼、识众寡之用、上下同欲、以虞待不虞、将能而君不御。</li><li><strong>将领是国家安危的决定者：</strong> 孙子强调了将领在战争中的重要作用，认为将领要能够根据情况灵活运用兵法，避免縻军和乱军引胜的错误。</li></ul><h1 id="军形第四"><a href="#军形第四" class="headerlink" title="军形第四"></a>军形第四</h1><p><strong>先为不可胜，以待敌之可胜</strong></p><p><strong>先为不可胜，以待敌之可胜。不可胜在己，可胜在敌。故善战者，能为不可胜，不能使敌之必可胜。故曰：胜可知，而不可为。</strong></p><ul><li><strong>不可胜在己</strong>：优秀的将领首先要确保自己立于不败之地，这取决于自身的准备和防御。</li><li><strong>可胜在敌</strong>：胜利的机会则是由敌人的错误或弱点决定的。</li><li><strong>胜可知，而不可为</strong>：胜利的条件可以被预知，但不能强行制造。</li></ul><h1 id="兵势第五"><a href="#兵势第五" class="headerlink" title="兵势第五"></a>兵势第五</h1><p><strong>凡战者，以正合，以奇胜。</strong></p><ul><li><strong>以正合</strong>：用常规的战术进行交战。</li><li><strong>以奇胜</strong>：用出其不意的战术取得胜利。</li></ul><h1 id="虚实第六"><a href="#虚实第六" class="headerlink" title="虚实第六"></a>虚实第六</h1><p><strong>故善战者，致人而不致于人。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 经典书籍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaEE技能树</title>
      <link href="/posts/f1b25278/"/>
      <url>/posts/f1b25278/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h1><p><img src="/../images/WX20240413-160908.png" alt="WX20240413-160908.png"></p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> JAVAEE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-04日记</title>
      <link href="/posts/42a306ee/"/>
      <url>/posts/42a306ee/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="389d3129b6094ba5d29362e1ee307ffc6f26cd450f9b0a8c6fc86cfeb991066e">026422d16125c0ef5486e4aca3c5daf506eac8b704d20a3e10d8dbe17b8641d586f098f2562ff378c8eaefc40cd08645fcb781c0c27175247887a8fa63710904c5fb41cc2077160fcb551c7176b562e7f0b1d3a29e848d56e354e3210cfad118b2029c1e8a692a35b614a0c9f658fa58fea90d31e7290f42931238ec4b8ecacbf28732c97ffd1f634c82720f065aa369dda264374aa10d648358b07e415b465fa735ba3ad5f3c0dcb85a1da85c1629e757cf15c3aa70d7f2ede01d21306263745580f3ddb8adfdad4df15f8cd5a62daba64728abef01e8ae81a30b0d6ebe8c718ae84e33b8fb54ec5678958061dc8169ffd09fd6fd30c5a7b9b776196804278d1993d6dfba0d071c17b90f21e47bc69235841f933867bc3aa64bf502902f88e0b9844d7302ac71d9c7efa75c8619cf7cdc48eb61e7ee326f5d60d75aadc881a707ea0d048b7768fa3c78bf19ba018e271bf772477242581e58663ac51ca4469f10aa2fe0c9c2261d71c384f4286713077da0553a25ac2f86397b21afdd3536552b0ee448b24c5a94371ed70d194456e03c31cc53ee529f9adb2ad4cf900f68f3190070be1b3a4aa494977050be616ba37d9a7cb32afc460d76b348ab5f40b99d16f654858f216fb7d4fa02f53c8c6d4e1dcc00fa19e2ad725c3b4a2d8938226148231bc122fc064416ffb01ee4ad865e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spirng基础</title>
      <link href="/posts/3fed9f30/"/>
      <url>/posts/3fed9f30/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC 控制反转"></a>IOC 控制反转</h1><ol><li>IOC控制反转，全称（Inversion of Control）是一种设计理念。</li><li>IOC的目的是降低对象之间直接耦合。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）</li><li>由代理人来创建和管理对象，消费者通过代理人来获取对象。</li><li>加入IOC容器将对象统一管理，让对象关联变为弱耦合。</li></ol><p><img src="/../images/1957695-da23d0a0760c6e7e.webp" alt="1957695-da23d0a0760c6e7e.webp"><br><img src="/../images/1957695-bdb55bb000ae89ec.webp" alt="1957695-bdb55bb000ae89ec.webp"></p><span id="more"></span><h1 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h1><ol><li>IOC是设计理念,是现代程序设计遵循的标准,是宏观目标。</li><li>Dl(Dependency Injection)是具体技术实现,是微观实现。</li><li>狭义的Spring是指Spring框架(Spring Framework)</li><li>广义的Spring是指Spring生态体系</li></ol><h1 id="狭义的Spring框架"><a href="#狭义的Spring框架" class="headerlink" title="狭义的Spring框架"></a>狭义的Spring框架</h1><ol><li><p>Spring框架是企业开发复杂性的一站式解决方案</p></li><li><p>Spring框架的核心是IOC容器与AOP面向切面编程</p></li><li><p>Spring IOC负责创建与管理系统对象，并在此基础上扩展功能</p></li><li><p>DI在Java中利用反射技术实现对象注入(Injection)</p></li></ol><h1 id="Spring的含义"><a href="#Spring的含义" class="headerlink" title="Spring的含义"></a>Spring的含义</h1><ol><li>Spring可从狭义与广义两个角度看待</li></ol><h1 id="广义的Spring生态体系"><a href="#广义的Spring生态体系" class="headerlink" title="广义的Spring生态体系"></a>广义的Spring生态体系</h1><p><img src="/../images/WX20240402-181512.png" alt="WX20240402-181512.png"></p><h1 id="IOC-和传统开发对比"><a href="#IOC-和传统开发对比" class="headerlink" title="IOC 和传统开发对比"></a>IOC 和传统开发对比</h1><ol><li>对象直接引用导致对象硬性关联，程序难以扩展维护。</li><li>IOC容器是Spring生态的基地，用于统一创建与管理对象依赖。</li></ol><p><img src="/../images/WX20240402-191505@2x.png" alt="WX20240402-191505@2x.png"><br><img src="/../images/WX20240402-191652@2x.png" alt="WX20240402-191652@2x.png"></p><h1 id="Spring-IOC容器职责"><a href="#Spring-IOC容器职责" class="headerlink" title="Spring IOC容器职责"></a>Spring IOC容器职责</h1><ol><li>对象的控制权交由第三方统一管理（IOC控制反转）</li><li>利用Java反射技术实现运行时对象创建与关联（DI依赖注入）</li><li>基于配置提高应用程序的可维护性与扩展性</li></ol><h1 id="初始化IOC容器"><a href="#初始化IOC容器" class="headerlink" title="初始化IOC容器"></a>初始化IOC容器</h1><h2 id="XML管理对象（Bean）"><a href="#XML管理对象（Bean）" class="headerlink" title="XML管理对象（Bean）"></a>XML管理对象（Bean）</h2><p>有以下三种方式</p><ol><li>基于XML配置Bean</li><li>基于注解配置Bean</li><li>基于Java代码配置Bean</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.jianshu.com/p/07af9dbbbc4b">控制反转（IoC）与依赖注入（DI）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> JAVAEE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Application的理解</title>
      <link href="/posts/ea5de885/"/>
      <url>/posts/ea5de885/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Application的生命周期"><a href="#Application的生命周期" class="headerlink" title="Application的生命周期"></a>Application的生命周期</h1><ol><li>构造函数</li><li>attachBaseContext</li><li>onCreate</li></ol><span id="more"></span><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>不要在Application的生命周期中做耗时操作，因为Application的生命周期都是在UI线程中进行的，Application初始化完成之后，就会立即初始化四大组件，要是我们在Application的生命周期中做了耗时操作，就会阻塞四大组件的初始化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Context的理解</title>
      <link href="/posts/4c51f887/"/>
      <url>/posts/4c51f887/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="context是什么？"><a href="#context是什么？" class="headerlink" title="context是什么？"></a>context是什么？</h1><p>Context 意为上下文，是一个应用程序环境信息的接口。通过Context可以访问系统资源，系统服务等。</p><h1 id="应用中一共有几个-Context-对象"><a href="#应用中一共有几个-Context-对象" class="headerlink" title="应用中一共有几个 Context 对象"></a>应用中一共有几个 Context 对象</h1><p>Context数量 &#x3D; Activity + Service + Application;</p><span id="more"></span><h1 id="Context的继承关系"><a href="#Context的继承关系" class="headerlink" title="Context的继承关系"></a>Context的继承关系</h1><ol><li>Activity和UI相关继承了ContextThemeWrapper</li></ol><p><img src="/../images/690292-20171124104943125-199635726.png" alt="690292-20171124104943125-199635726.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓UI体系</title>
      <link href="/posts/c17ff4c4/"/>
      <url>/posts/c17ff4c4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Surface跨进程传递"><a href="#Surface跨进程传递" class="headerlink" title="Surface跨进程传递"></a>Surface跨进程传递</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-----&gt; /frameworks/native/libs/gui/SurfaceControl.<span class="function">cpp</span></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::getSurface</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateSurfaceLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::generateSurfaceLocked</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn&#x27;t matter; using false.</span></span><br><span class="line">    <span class="comment">//使用GraphicBufferProducer创建了一个Surface</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> <span class="built_in">Surface</span>(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>surface它只是一个壳子，而不是buffer对象，surface里面包含了一个能生产buffer的binder对象，也就是GraphicBufferProducer。</li><li>surface跨进程传递，本质是GraphicBufferProducer的传递</li></ol><span id="more"></span><h1 id="Surface的绘制原理"><a href="#Surface的绘制原理" class="headerlink" title="Surface的绘制原理"></a>Surface的绘制原理</h1><h2 id="Surface的Buffer是从怎么来的？"><a href="#Surface的Buffer是从怎么来的？" class="headerlink" title="Surface的Buffer是从怎么来的？"></a>Surface的Buffer是从怎么来的？</h2><p>&#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;include&#x2F;gui&#x2F;BufferQueueCore.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mSlots is an array of buffer slots that must be mirrored on the producer</span></span><br><span class="line">    <span class="comment">// side. This allows buffer ownership to be transferred between the producer</span></span><br><span class="line">    <span class="comment">// and consumer without sending a GraphicBuffer over Binder. The entire</span></span><br><span class="line">    <span class="comment">// array is initialized to NULL at construction time, and buffers are</span></span><br><span class="line">    <span class="comment">// allocated for a slot when requestBuffer is called with that slot&#x27;s index.    //  typedef BufferSlot SlotsType[NUM_BUFFER_SLOTS];    //  static constexpr int NUM_BUFFER_SLOTS = 64;</span></span><br><span class="line">    BufferQueueDefs::SlotsType mSlots;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mQueue is a FIFO of queued buffers used in synchronous mode.</span></span><br><span class="line">    Fifo mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mFreeSlots contains all of the slots which are FREE and do not currently</span></span><br><span class="line">    <span class="comment">// have a buffer attached.</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mFreeSlots;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mFreeBuffers contains all of the slots which are FREE and currently have</span></span><br><span class="line">    <span class="comment">// a buffer attached.</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mFreeBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mUnusedSlots contains all slots that are currently unused. They should be</span></span><br><span class="line">    <span class="comment">// free and not have a buffer attached.</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mUnusedSlots;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mActiveBuffers contains all slots which have a non-FREE buffer attached.</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mActiveBuffers;</span><br></pre></td></tr></table></figure><ol><li>通过mGaphicBufferProducer-&gt;dequeteBuffer()函数在远端的BufferQueue的Buffer slots中获得一个空闲的Buffer，返回远端Buffer地址指针。</li></ol><p><img src="/../images/170b835110e4f3aa~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp" alt="170b835110e4f3aa~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp"></p><h2 id="buffer是如何提交的？"><a href="#buffer是如何提交的？" class="headerlink" title="buffer是如何提交的？"></a>buffer是如何提交的？</h2><ol><li>通过mGraphicBufferProducer-&gt;queueBuffer(i, )函数，将本地的Buffer同步到远端Buffer queue中。</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.cnblogs.com/naray/p/15363076.html">Android之Surface绘制原理 </a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/posts/92933cdb/"/>
      <url>/posts/92933cdb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AOP-底层技术比较"><a href="#AOP-底层技术比较" class="headerlink" title="AOP 底层技术比较"></a>AOP 底层技术比较</h1><p><img src="/../images/WX20240401-094133@2x.png" alt="WX20240401-094133@2x.png"></p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio</title>
      <link href="/posts/737f3f95/"/>
      <url>/posts/737f3f95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="阿里镜像"><a href="#阿里镜像" class="headerlink" title="阿里镜像"></a>阿里镜像</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/central&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/jcenter&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/google&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/gradle-plugin&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span>) &#125;</span><br><span class="line">maven &#123; setUrl(<span class="string">&quot;https://jitpack.io&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UI渲染优化</title>
      <link href="/posts/e0219194/"/>
      <url>/posts/e0219194/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UI-优化的常用手段"><a href="#UI-优化的常用手段" class="headerlink" title="UI 优化的常用手段"></a>UI 优化的常用手段</h1><h2 id="尽量使用硬件加速"><a href="#尽量使用硬件加速" class="headerlink" title="尽量使用硬件加速"></a>尽量使用硬件加速</h2><h2 id="Create-View-优化"><a href="#Create-View-优化" class="headerlink" title="Create View 优化"></a>Create View 优化</h2><ol><li><p>View 的创建也是在 UI 线程里。</p></li><li><p>View 创建的耗时，可能会包括各种 XML 的随机读的 I&#x2F;O 时间、解析 XML 的时间、生成对象的时间（Framework 会大量使用到反射）。</p></li></ol><span id="more"></span><p><strong>1. 使用代码创建</strong></p><p><strong>2. 异步创建</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(12).png" alt="下载 (12).png"></p><p>在创建完 View 后我们需要把线程的 Looper 恢复成原来的。</p><p><strong>3. View 重用</strong></p><h2 id="measure-layout-优化"><a href="#measure-layout-优化" class="headerlink" title="measure&#x2F;layout 优化"></a>measure&#x2F;layout 优化</h2><ol><li><p>减少 UI 布局层次。例如尽量扁平化，使用<ViewStub> <Merge>等优化。</p></li><li><p>优化 layout 的开销。尽量不使用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大。这里我推荐使用 ConstraintLayout 替代 RelativeLayout 或者 weighted LinearLayout。</p></li><li><p>背景优化。尽量不要重复去设置背景，这里需要注意的是主题背景（theme)， theme 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景我们来说是无用的。但是由于主题背景是设置在 DecorView 中，所以这里会带来重复绘制，也会带来绘制性能损耗。</p></li></ol><p>Textview 是系统控件中非常强大也非常重要的一个控件，强大的背后就代表着需要做很多计算。在 2018 年的 Google I&#x2F;O 大会，发布了PrecomputedText并已经集成在 Jetpack 中，它给我们提供了接口，可以异步进行 measure 和 layout，不必在主线程中执行。</p><h1 id="UI-优化的进阶手段"><a href="#UI-优化的进阶手段" class="headerlink" title="UI 优化的进阶手段"></a>UI 优化的进阶手段</h1><h2 id="Litho"><a href="#Litho" class="headerlink" title="Litho"></a>Litho</h2><p><strong>1. 异步布局</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(13).png" alt="下载 (13).png"></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(14).png" alt="下载 (14).png"></p><p><strong>2. 界面扁平化</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(15).png" alt="下载 (15).png"></p><p>Litho缺点：适合轻量级页面，交互不复杂的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UI渲染</title>
      <link href="/posts/cc16d703/"/>
      <url>/posts/cc16d703/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h1><p>UI 渲染还依赖两个核心的硬件：CPU 与 GPU。UI 组件在绘制到屏幕之前，都需要经过 Rasterization（栅格化）操作，而栅格化操作又是一个非常耗时的操作。GPU（Graphic Processing Unit ）也就是图形处理器，它主要用于处理图形运算，可以帮助我们加快栅格化操作。</p><p>栅格化：指将指令转化为像素的过程。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD.png" alt="下载.png"></p><p>软件绘制使用的是 Skia 库，它是一款能在低端设备如手机上呈现高质量的 2D 跨平台图形框架，类似 Chrome、Flutter 内部使用的都是 Skia 库。</p><span id="more"></span><h1 id="OpenGL-与-Vulkan"><a href="#OpenGL-与-Vulkan" class="headerlink" title="OpenGL 与 Vulkan"></a>OpenGL 与 Vulkan</h1><p>对于硬件绘制，我们通过调用 OpenGL ES 接口利用 GPU 完成绘制。OpenGL是一个跨平台的图形 API，它为 2D&#x2F;3D 图形处理硬件指定了标准软件接口。而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。</p><p>在官方<a href="https://developer.android.com/topic/performance/hardware-accel?hl=zh-cn">硬件加速的文档</a>中，可以看到很多 API 都有相应的 Android API level 限制。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(1).png" alt="下载 (1).png"></p><p>这是为什么呢？其实这主要是受OpenGL ES版本与系统支持的限制，直到最新的 Android P，有 3 个 API 是仍然没有支持。对于不支持的 API，我们需要使用软件绘制模式，渲染的性能将会大大降低。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(2).png" alt="下载 (2).png"></p><p>Android 7.0 把 OpenGL ES 升级到最新的 3.2 版本同时，还添加了对Vulkan的支持。Vulkan 是用于高性能 3D 图形的低开销、跨平台 API。相比 OpenGL ES，Vulkan 在改善功耗、多核优化提升绘图调用上有着非常明显的优势。</p><p>重点关注Vulkan。OpenGL已经不在维护了。</p><h1 id="Android-渲染的演进"><a href="#Android-渲染的演进" class="headerlink" title="Android 渲染的演进"></a>Android 渲染的演进</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(3).png" alt="下载 (3).png"></p><p>一个生动的比喻，如果把应用程序图形渲染过程当作一次绘画过程，那么绘画过程中 Android 的各个图形组件的作用是：</p><ol><li><p>画笔：Skia 或者 OpenGL。我们可以用 Skia 画笔绘制 2D 图形，也可以用 OpenGL 来绘制 2D&#x2F;3D 图形。正如前面所说，前者使用 CPU 绘制，后者使用 GPU 绘制。</p></li><li><p>画纸：Surface。所有的元素都在 Surface 这张画纸上进行绘制和渲染。在 Android 中，Window 是 View 的容器，每个窗口都会关联一个 Surface。而 WindowManager 则负责管理这些窗口，并且把它们的数据传递给 SurfaceFlinger。</p></li><li><p>画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，在 Android 4.1 之前使用的是双缓冲机制；在 Android 4.1 之后，使用的是三缓冲机制。</p></li><li><p>显示：SurfaceFlinger。它将 WindowManager 提供的所有 Surface，通过硬件合成器 Hardware Composer 合成并输出到显示屏。</p></li></ol><h2 id="Android-4-0：开启硬件加速"><a href="#Android-4-0：开启硬件加速" class="headerlink" title="Android 4.0：开启硬件加速"></a>Android 4.0：开启硬件加速</h2><p>在 Android 3.0 之前，或者没有启用硬件加速时，系统都会使用软件方式来渲染 UI。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(4).png" alt="下载 (4).png"></p><ol><li><p>Surface。每个 View 都由某一个窗口管理，而每一个窗口都关联有一个 Surface。</p></li><li><p>Canvas。通过 Surface 的 lock 函数获得一个 Canvas，Canvas 可以简单理解为 Skia 底层接口的封装。</p></li><li><p>Graphic Buffer。SurfaceFlinger 会帮我们托管一个BufferQueue，我们从 BufferQueue 中拿到 Graphic Buffer，然后通过 Canvas 以及 Skia 将绘制内容栅格化到上面。</p></li><li><p>SurfaceFlinger。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFinger，最后硬件合成器 Hardware Composer 合成并输出到显示屏。</p></li></ol><p><strong>硬件加速绘制</strong></p><p>所以从 Androd 3.0 开始，Android 开始支持硬件加速，到 Android 4.0 时，默认开启硬件加速。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(5).png" alt="下载 (5).png"></p><p>硬件加速绘制与软件绘制整个流程差异非常大，最核心就是我们通过 GPU 完成 Graphic Buffer 的内容绘制。此外硬件绘制还引入了一个 DisplayList 的概念，每个 View 内部都有一个 DisplayList，当某个 View 需要重绘时，将它标记为 Dirty。</p><p>当需要重绘时，仅仅只需要重绘一个 View 的 DisplayList，而不是像软件绘制那样需要向上递归。这样可以大大减少绘图的操作数量，因而提高了渲染效率。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(6).png" alt="下载 (6).png"></p><h2 id="Android-4-1：Project-Butter"><a href="#Android-4-1：Project-Butter" class="headerlink" title="Android 4.1：Project Butter"></a>Android 4.1：Project Butter</h2><p>Project Butter 主要包含两个组成部分，一个是 VSYNC，一个是 Triple Buffering。</p><p><strong>VSYNC 信号</strong></p><p>在讲文件 I&#x2F;O 跟网络 I&#x2F;O 的时候，我讲到过中断的概念。对于 Android 4.0，CPU 可能会因为在忙别的事情，导致没来得及处理 UI 绘制。</p><p>为解决这个问题，Project Buffer 引入了VSYNC，它类似于时钟中断。每收到 VSYNC 中断，CPU 会立即准备 Buffer 数据，由于大部分显示设备刷新频率都是 60Hz（一秒刷新 60 次），也就是说一帧数据的准备工作都要在 16ms 内完成。</p><p>这样应用总是在 VSYNC 边界上开始绘制，而 SurfaceFlinger 总是 VSYNC 边界上进行合成。这样可以消除卡顿，并提升图形的视觉表现。</p><p><strong>三缓冲机制 Triple Buffering</strong></p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(7).png" alt="下载 (7).png"></p><p>在 Android 4.1 之前，Android 使用双缓冲机制。怎么理解呢？一般来说，不同的 View 或者 Activity 它们都会共用一个 Window，也就是共用同一个 Surface。</p><p>而每个 Surface 都会有一个 BufferQueue 缓存队列，但是这个队列会由 SurfaceFlinger 管理，通过匿名共享内存机制与 App 应用层交互。</p><p>整个流程如下：</p><p>每个 Surface 对应的 BufferQueue 内部都有两个 Graphic Buffer ，一个用于绘制一个用于显示。我们会把内容先绘制到离屏缓冲区（OffScreen Buffer），在需要显示时，才把离屏缓冲区的内容通过 Swap Buffer 复制到 Front Graphic Buffer 中。</p><p>这样 SurfaceFlinge 就拿到了某个 Surface 最终要显示的内容，但是同一时间我们可能会有多个 Surface。这里面可能是不同应用的 Surface，也可能是同一个应用里面类似 SurefaceView 和 TextureView，它们都会有自己单独的 Surface。</p><p>这个时候 SurfaceFlinger 把所有 Surface 要显示的内容统一交给 Hareware Composer，它会根据位置、Z-Order 顺序等信息合成为最终屏幕需要显示的内容，而这个内容会交给系统的帧缓冲区 Frame Buffer 来显示（Frame Buffer 是非常底层的，可以理解为屏幕显示的抽象）。</p><p>如果你理解了双缓冲机制的原理，那就非常容易理解什么是三缓冲区了。如果只有两个 Graphic Buffer 缓存区 A 和 B，如果 CPU&#x2F;GPU 绘制过程较长，超过了一个 VSYNC 信号周期，因为缓冲区 B 中的数据还没有准备完成，所以只能继续展示 A 缓冲区的内容，这样缓冲区 A 和 B 都分别被显示设备和 GPU 占用，CPU 无法准备下一帧的数据。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(8).png" alt="下载 (8).png"></p><p>如果再提供一个缓冲区，CPU、GPU 和显示设备都能使用各自的缓冲区工作，互不影响。简单来说，三缓冲机制就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的了一个 Graphic Buffer 所占用的内存。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(9).png" alt="下载 (9).png"></p><p>对于 VSYNC 信号和 Triple Buffering 更详细的介绍，可以参考<a href="https://blog.csdn.net/innost/article/details/8272867">《Android Project Butter 分析》</a>。</p><h2 id="Android-5-0：RenderThread"><a href="#Android-5-0：RenderThread" class="headerlink" title="Android 5.0：RenderThread"></a>Android 5.0：RenderThread</h2><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(10).png" alt="下载 (10).png"></p><p>在 Android 5.0 引入了两个比较大的改变。一个是引入了 RenderNode 的概念，它对 DisplayList 及一些 View 显示属性做了进一步封装。另一个是引入了 RenderThread，所有的 GL 命令执行都放到这个线程上，渲染线程在 RenderNode 中存有渲染帧的所有信息，可以做一些属性动画，这样即便主线程有耗时操作的时候也可以保证动画流畅。</p><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(11).png" alt="下载 (11).png"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li>20 | UI 优化（上）：UI 渲染的几个关键概念</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节码插桩</title>
      <link href="/posts/cad98d1c/"/>
      <url>/posts/cad98d1c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle</title>
      <link href="/posts/18596a3e/"/>
      <url>/posts/18596a3e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Gradle-插件简介"><a href="#Gradle-插件简介" class="headerlink" title="Gradle 插件简介"></a>Gradle 插件简介</h1><ol><li><p>Gradle是一个构建工具，负责让工程构建变得更自动化。不过它只是一个执行环境，提供了基本的框架，而真正的构建行为不是由他自己去提供的。 Gradle负责在运行的时候，找到所有需要执行的Task，依次来执行。</p></li><li><p>在Gradle的世界中，几乎所有的功能都是以插件的方式去提供的。</p></li><li><p>Gradle 插件则是运行在这套机制上的一些具体构建功能（Task），本质上和 .gradle 文件是相同。例如，我们熟悉的编译 Java 代码的能力，都是由插件提供的。</p></li><li><p>Gradle插件可以提高代码复用性。</p></li></ol><span id="more"></span><h1 id="Gradle插件分类"><a href="#Gradle插件分类" class="headerlink" title="Gradle插件分类"></a>Gradle插件分类</h1><p>Gradle 插件分为 二进制插件 和脚本插件。</p><h1 id="二进制插件使用"><a href="#二进制插件使用" class="headerlink" title="二进制插件使用"></a>二进制插件使用</h1><ol><li>在项目根目录的build.gradle里面声明插件ID与版本号。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">//声明插件ID与版本号</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&quot;com.android.tools.build:gradle:7.1.3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在工程app的build.gradle应用插件和配置插件</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用插件</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置插件</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;30.0.3&quot;</span></span><br><span class="line"></span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="脚本插件的使用"><a href="#脚本插件的使用" class="headerlink" title="脚本插件的使用"></a>脚本插件的使用</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other.gradle 在app目录</span></span><br><span class="line">apply <span class="keyword">from</span>: <span class="string">&#x27;other.gradle&#x27;</span></span><br><span class="line"><span class="comment">// other.gradle 在项目根目录</span></span><br><span class="line">apply <span class="keyword">from</span>:<span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">&quot;other.gradle&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><h2 id="建立buildSrc子工程"><a href="#建立buildSrc子工程" class="headerlink" title="建立buildSrc子工程"></a>建立buildSrc子工程</h2><ol><li><p>在项目根目录建立buildSrc文件夹，名字是Gradle固定的。<br><img src="/../images/WX20240330-193800.png" alt="WX20240330-193800.png"></p></li><li><p>在buildSrc目录下，创建build.gradle文件，并进行工程配置。</p></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用groovy插件，编译插件工程中的代码</span></span><br><span class="line">apply plugin: <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明仓库的地址</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明依赖的包</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建立插件运行入口"><a href="#建立插件运行入口" class="headerlink" title="建立插件运行入口"></a>建立插件运行入口</h2><p><img src="/../images/WX20240330-153412.png" alt="WX20240330-153412.png"></p><ol><li>建立RouterPlugin.groovy入口，并实现apply方法，注入插件的逻辑。</li></ol><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><ol><li>定义Extension,在Gradle目录下建立RouterExtension.groovy文件。并在RouterExtension.groovy定义保存的路径wikiDir。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.router.demo.gradle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RouterExtension &#123;</span><br><span class="line">    String wikiDir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注册Extension。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">void</span> apply(<span class="keyword">Project</span> <span class="keyword">project</span>) &#123;</span><br><span class="line">    <span class="keyword">println</span>(<span class="string">&quot;我来自于 routerPlugin, apply from $&#123;project.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册Extension</span></span><br><span class="line">    <span class="keyword">project</span>.getExtensions().create(<span class="string">&quot;router&quot;</span>, RouterExtension)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用Extension。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    alias(libs.plugins.androidApplication)</span><br><span class="line">    alias(libs.plugins.jetbrainsKotlinAndroid)</span><br><span class="line">    <span class="comment">// 应用插件</span></span><br><span class="line">    alias(libs.plugins.routerPlugin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router &#123;</span><br><span class="line">    wikiDir getRootDir().absolutePath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>获取Extension</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> apply(<span class="keyword">Project</span> <span class="keyword">project</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 获取Extension</span></span><br><span class="line">    <span class="keyword">project</span>.afterEvaluate &#123;</span><br><span class="line">        RouterExtension routerExtension = <span class="keyword">project</span>[<span class="string">&quot;router&quot;</span>]</span><br><span class="line">        <span class="keyword">println</span>(<span class="string">&quot;用户设置的wiki路径:$&#123;routerExtension.wikiDir&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h2><ol><li>在buildSrc目录下的build.gradle 中添加下面的代码。</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用maven插件，用于发布</span></span><br><span class="line">apply plugin: <span class="string">&#x27;maven&#x27;</span></span><br><span class="line"><span class="comment">// 配置maven插件中的uploadArchives任务</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">// 设置发布路径为 工程目录下面的repo文件件</span></span><br><span class="line">            repository(url: uri(<span class="string">&#x27;../repo&#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 设置groupId 通常为包名</span></span><br><span class="line">                pom.groupId = <span class="string">&#x27;com.imooc.router&#x27;</span></span><br><span class="line">                <span class="comment">// 设置artifactId, 为当前插件的名称</span></span><br><span class="line">                pom.artifactId = <span class="string">&#x27;router-gradle-plugin&#x27;</span></span><br><span class="line">                <span class="comment">// 设置 插件的版本号</span></span><br><span class="line">                pom.version = <span class="string">&#x27;1.0.0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>因为不能在buildSrc目录发布，所以 执行<code>cp -rf buildSrc router-gradle-plugin</code>命令，复制buildSrc目录，命名为router-gradle-plugin目录。</li></ol><p><img src="/../images/WX20240330-165955.png" alt="WX20240330-165955.png"></p><ol start="3"><li>在<code>settings.gradle.kts</code>中引入<code>router-gradle-plugin</code>.<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">&quot;:app&quot;</span>,<span class="string">&quot;router-gradle-plugin&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>执行<code>./gradlew :router-gradle-plugin:publish --warning-mode all </code>命令发布插件。<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">huawei@huaweideMacBook-Pro ~<span class="regexp">/A/G</span>rdlePlugin [<span class="number">1</span>]&gt; ./gradlew :router-gradle-plugin:publish --warning-mode all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in <span class="number">3</span>s</span><br><span class="line"><span class="number">9</span> actionable tasks: <span class="number">6</span> executed, <span class="number">3</span> up-to-date</span><br><span class="line">huawei@huaweideMacBook-Pro ~<span class="regexp">/A/G</span>rdlePlugin&gt; </span><br></pre></td></tr></table></figure></li></ol><p>生成repo文件夹。</p><p><img src="/../images/WX20240330-180008.png" alt="WX20240330-180008.png"></p><p><a href="https://github.com/shizhongyu/GrdlePlugin">完整代码</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://doc.qzxdp.cn/gradle/8.1.1/userguide/what_is_gradle.html">Gradle文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ANR全面解析</title>
      <link href="/posts/c6084ae/"/>
      <url>/posts/c6084ae/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>解决ANR(Application Not Responding)一直是Android 开发者需要掌握的重要技巧，一般从三个方面着手。</p><ol><li>开发阶段：通过工具检查各个方法的耗时，卡顿情况，发现一处修改一处。</li><li>线上阶段：这个阶段主要依靠监控工具发现ANR并上报，比如matrix。</li><li>分析阶段：如果线上用户发生ANR，并且你获取了一份日志，这就涉及了本文要分享的内容——ANR日志分析技巧。</li></ol><span id="more"></span><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>主线程的消息得不到及时响应。</p><p>很多开发者认为，那就是耗时操作导致ANR，全部是app应用层的问题。实际上，线上环境大部分ANR由系统原因导致。</p><h2 id="应用层导致ANR（耗时操作）"><a href="#应用层导致ANR（耗时操作）" class="headerlink" title="应用层导致ANR（耗时操作）"></a>应用层导致ANR（耗时操作）</h2><ol><li>函数阻塞：如死循环、主线程IO、处理大数据</li><li>锁出错：主线程等待子线程的锁</li><li>内存紧张：系统分配给一个应用的内存是有上限的，长期处于内存紧张，会导致频繁内存交换，进而导致应用的一些操作超时</li></ol><h2 id="系统导致ANR"><a href="#系统导致ANR" class="headerlink" title="系统导致ANR"></a>系统导致ANR</h2><ol><li>CPU被抢占：一般来说，前台在玩游戏，可能会导致你的后台广播被抢占CPU</li><li>系统服务无法及时响应：比如获取系统联系人等，系统的服务都是Binder机制，服务能力也是有限的，有可能系统服务长时间不响应导致ANR</li><li>其他应用占用的大量内存</li></ol><h1 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h1><p>发生ANR的时候，系统会产生一份anr日志文件（手机的&#x2F;data&#x2F;anr 目录下，文件名称可能各厂商不一样，业内大多称呼为trace文件），内含如下几项重要信息。</p><h2 id="CPU-负载"><a href="#CPU-负载" class="headerlink" title="CPU 负载"></a>CPU 负载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Load: <span class="number">2.62</span> / <span class="number">2.55</span> / <span class="number">2.25</span></span><br><span class="line">CPU usage from 0ms to 1987ms <span class="title function_">later</span> <span class="params">(<span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">31</span>:<span class="number">55.169</span> to <span class="number">2020</span>-<span class="number">03</span>-<span class="number">10</span> 08:<span class="number">32</span>:<span class="number">17.156</span>)</span>:</span><br><span class="line">  <span class="number">41</span>% <span class="number">2080</span>/system_server: <span class="number">28</span>% user + <span class="number">12</span>% kernel / faults: <span class="number">76445</span> minor <span class="number">180</span> major</span><br><span class="line">  <span class="number">26</span>% <span class="number">9378</span>/com.xiaomi.store: <span class="number">20</span>% user + <span class="number">6.8</span>% kernel / faults: <span class="number">68408</span> minor <span class="number">68</span> major</span><br><span class="line">........省略N行.....</span><br><span class="line"><span class="number">66</span>% TOTAL: <span class="number">20</span>% user + <span class="number">15</span>% kernel + <span class="number">28</span>% iowait + <span class="number">0.7</span>% irq + <span class="number">0.7</span>% softirq</span><br></pre></td></tr></table></figure><ol><li>第一行：1、5、15 分钟内正在使用和等待使用CPU 的活动进程的平均数</li><li>第二行：表明负载信息抓取在ANR发生之后的0~1987ms。同时也指明了ANR的时间点：2020-03-10 08:31:55.169</li><li>中间部分：各个进程占用的CPU的详细情况</li><li>最后一行：各个进程合计占用的CPU信息。</li></ol><p>名词解释</p><ol><li>user:用户态,kernel:内核态</li><li>faults:内存缺页，minor——轻微的，major——重度，需要从磁盘拿数据</li><li>iowait:IO使用（等待）占比</li><li>irq:硬中断，softirq:软中断</li></ol><p>注意</p><ol><li>iowait占比很高，意味着有很大可能，是io耗时导致ANR，具体进一步查看有没有进程faults major比较多。</li><li>单进程CPU的负载并不是以100%为上限，而是有几个核，就有百分之几百，如4核上限为400%。</li></ol><h2 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h2><ol><li>Total number of allocations 476778　　进程创建到现在一共创建了多少对象</li><li>Total bytes allocated 52MB　进程创建到现在一共申请了多少内存</li><li>Total bytes freed 52MB　　　进程创建到现在一共释放了多少内存</li><li>Free memory 777KB　　　 不扩展堆的情况下可用的内存</li><li>Free memory until GC 777KB　　GC前的可用内存</li><li>Free memory until OOME 383MB　　OOM之前的可用内存</li><li>Total memory 当前总内存（已用+可用）</li><li>Max memory 384MB  进程最多能申请的内存</li></ol><p>从含义可以得出结论：**Free memory until OOME **的值很小的时候，已经处于内存紧张状态。应用可能是占用了过多内存。</p><p>另外，除了trace文件中有内存信息，普通的eventlog日志中，也有内存信息（不一定打印）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">04</span>-<span class="number">02</span> <span class="number">22</span>:<span class="number">00</span>:<span class="number">08.195</span>  <span class="number">1531</span>  <span class="number">1544</span> I am_meminfo: [<span class="number">350937088</span>,<span class="number">41086976</span>,<span class="number">492830720</span>,<span class="number">427937792</span>,<span class="number">291887104</span>]</span><br></pre></td></tr></table></figure><p>以上四个值分别指的是：</p><ol><li>Cached</li><li>Free,</li><li>Zram,</li><li>Kernel,Native</li></ol><p>Cached+Free的内存代表着当前整个手机的可用内存，如果值很小，意味着处于内存紧张状态。一般低内存的判定阈值为：4G 内存手机以下阀值：350MB，以上阀值则为：450MB<br>ps:如果ANR时间点前后，日志里有打印onTrimMemory，也可以作为内存紧张的一个参考判断</p><h2 id="堆栈消息"><a href="#堆栈消息" class="headerlink" title="堆栈消息"></a>堆栈消息</h2><p>堆栈信息是最重要的一个信息，展示了ANR发生的进程当前所有线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">suspend all histogram:  Sum: <span class="number">2.</span>834s <span class="number">99</span>% C.I. <span class="number">5.</span>738us-<span class="number">7145.</span>919us Avg: <span class="number">607.</span>155us Max: 41543us</span><br><span class="line">DALVIK <span class="title function_">THREADS</span> <span class="params">(<span class="number">248</span>)</span>:</span><br><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Native</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x74b17080</span> self=<span class="number">0x7bb7a14c00</span></span><br><span class="line">  | sysTid=<span class="number">2080</span> nice=-<span class="number">2</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x7c3e82b548</span></span><br><span class="line">  | state=S schedstat=( <span class="number">757205342094</span> <span class="number">583547320723</span> <span class="number">2145008</span> ) utm=<span class="number">52002</span> stm=<span class="number">23718</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7fdc995000</span>-<span class="number">0x7fdc997000</span> stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  kernel: __switch_to+<span class="number">0xb0</span>/<span class="number">0xbc</span></span><br><span class="line">  kernel: SyS_epoll_wait+<span class="number">0x288</span>/<span class="number">0x364</span></span><br><span class="line">  kernel: SyS_epoll_pwait+<span class="number">0xb0</span>/<span class="number">0x124</span></span><br><span class="line">  kernel: cpu_switch_to+<span class="number">0x38c</span>/<span class="number">0x2258</span></span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">00</span> pc 000000000007cd8c  /system/lib64/libc.so (__epoll_pwait+<span class="number">8</span>)</span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">01</span> pc 0000000000014d48  /system/lib64/libutils.so (android::Looper::pollInner(<span class="type">int</span>)+<span class="number">148</span>)</span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">02</span> pc 0000000000014c18  /system/lib64/libutils.so (android::Looper::pollOnce(<span class="type">int</span>, <span class="type">int</span>*, <span class="type">int</span>*, <span class="keyword">void</span>**)+<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">native</span>: #<span class="number">03</span> pc <span class="number">0000000000127474</span>  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, <span class="type">long</span>, <span class="type">int</span>)+<span class="number">44</span>)</span><br><span class="line">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">  at android.os.MessageQueue.next(MessageQueue.java:<span class="number">330</span>)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:<span class="number">169</span>)</span><br><span class="line">  at com.android.server.SystemServer.run(SystemServer.java:<span class="number">508</span>)</span><br><span class="line">  at com.android.server.SystemServer.main(SystemServer.java:<span class="number">340</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">536</span>)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">856</span>)</span><br><span class="line">   </span><br><span class="line">  ........省略N行.....</span><br><span class="line">   </span><br><span class="line">  <span class="string">&quot;OkHttp ConnectionPool&quot;</span> daemon prio=<span class="number">5</span> tid=<span class="number">251</span> TimedWaiting</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x13daea90</span> self=<span class="number">0x7bad32b400</span></span><br><span class="line">  | sysTid=<span class="number">29998</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x7b7d2614f0</span></span><br><span class="line">  | state=S schedstat=( <span class="number">951407</span> <span class="number">137448</span> <span class="number">11</span> ) utm=<span class="number">0</span> stm=<span class="number">0</span> core=<span class="number">3</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7b7d15e000</span>-<span class="number">0x7b7d160000</span> stackSize=1041KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Object.wait(Native method)</span><br><span class="line">  - waiting on &lt;<span class="number">0x05e5732e</span>&gt; (a com.android.okhttp.ConnectionPool)</span><br><span class="line">  at com.android.okhttp.ConnectionPool$<span class="number">1.</span>run(ConnectionPool.java:<span class="number">103</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x05e5732e</span>&gt; (a com.android.okhttp.ConnectionPool)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1167</span>)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">641</span>)</span><br><span class="line">  at java.lang.Thread.run(Thread.java:<span class="number">764</span>)</span><br></pre></td></tr></table></figure><p>如上日志所示，本文截图了两个线程信息，一个是主线程main，它的状态是native。<br>另一个是OkHttp ConnectionPool，它的状态是TimeWaiting。</p><p>trace文件中的状态是是CPP代码中定义的状态，(不是java的线程状态)下面是一张对应关系表。</p><p><img src="/../images/55ea536a4b3f4108abe5214f8ec15f0d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="55ea536a4b3f4108abe5214f8ec15f0d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><p>由此可知，main函数的native状态是正在执行JNI函数。堆栈信息是我们分析ANR的第一个重要的信息，一般来说：</p><ol><li>main线程处于 BLOCK、WAITING、TIMEWAITING状态，那基本上是函数阻塞导致ANR；</li><li>如果main线程无异常，则应该排查CPU负载和内存环境。</li></ol><h1 id="典型案例分析"><a href="#典型案例分析" class="headerlink" title="典型案例分析"></a>典型案例分析</h1><h2 id="主线程无卡顿，处于正常状态堆栈"><a href="#主线程无卡顿，处于正常状态堆栈" class="headerlink" title="主线程无卡顿，处于正常状态堆栈"></a>主线程无卡顿，处于正常状态堆栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Native</span><br><span class="line">| group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x74b38080</span> self=<span class="number">0x7ad9014c00</span></span><br><span class="line">| sysTid=<span class="number">23081</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x7b5fdc5548</span></span><br><span class="line">| state=S schedstat=( <span class="number">284838633</span> <span class="number">166738594</span> <span class="number">505</span> ) utm=<span class="number">21</span> stm=<span class="number">7</span> core=<span class="number">1</span> HZ=<span class="number">100</span></span><br><span class="line">| stack=<span class="number">0x7fc95da000</span>-<span class="number">0x7fc95dc000</span> stackSize=8MB</span><br><span class="line">| held mutexes=</span><br><span class="line">kernel: __switch_to+<span class="number">0xb0</span>/<span class="number">0xbc</span></span><br><span class="line">kernel: SyS_epoll_wait+<span class="number">0x288</span>/<span class="number">0x364</span></span><br><span class="line">kernel: SyS_epoll_pwait+<span class="number">0xb0</span>/<span class="number">0x124</span></span><br><span class="line">kernel: cpu_switch_to+<span class="number">0x38c</span>/<span class="number">0x2258</span></span><br><span class="line"><span class="keyword">native</span>: #<span class="number">00</span> pc 000000000007cd8c  /system/lib64/libc.so (__epoll_pwait+<span class="number">8</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">01</span> pc 0000000000014d48  /system/lib64/libutils.so (android::Looper::pollInner(<span class="type">int</span>)+<span class="number">148</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">02</span> pc 0000000000014c18  /system/lib64/libutils.so (android::Looper::pollOnce(<span class="type">int</span>, <span class="type">int</span>*, <span class="type">int</span>*, <span class="keyword">void</span>**)+<span class="number">60</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">03</span> pc 00000000001275f4  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, <span class="type">long</span>, <span class="type">int</span>)+<span class="number">44</span>)</span><br><span class="line">at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">at android.os.MessageQueue.next(MessageQueue.java:<span class="number">330</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">169</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7073</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">536</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">876</span>)</span><br></pre></td></tr></table></figure><p>上述主线程堆栈就是一个很正常的空闲堆栈，表明主线程正在等待新的消息。</p><p>如果ANR日志里主线程是这样一个状态，那可能有两个原因：</p><ol><li>该ANR是CPU抢占或内存紧张等其他因素引起</li><li>这份ANR日志抓取的时候，主线程已经恢复正常</li></ol><h2 id="主线程执行耗时操作"><a href="#主线程执行耗时操作" class="headerlink" title="主线程执行耗时操作"></a>主线程执行耗时操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Runnable</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">0</span> dsCount=<span class="number">0</span> flags=<span class="number">0</span> obj=<span class="number">0x72deb848</span> self=<span class="number">0x7748c10800</span></span><br><span class="line">  | sysTid=<span class="number">8968</span> nice=-<span class="number">10</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x77cfa75ed0</span></span><br><span class="line">  | state=R schedstat=( <span class="number">24783612979</span> <span class="number">48520902</span> <span class="number">756</span> ) utm=<span class="number">2473</span> stm=<span class="number">5</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7fce68b000</span>-<span class="number">0x7fce68d000</span> stackSize=8192KB</span><br><span class="line">  | held mutexes= <span class="string">&quot;mutator lock&quot;</span>(shared held)</span><br><span class="line">  at com.example.test.MainActivity$onCreate$<span class="number">2.</span>onClick(MainActivity.kt:<span class="number">20</span>)——关键行！！！</span><br><span class="line">  at android.view.View.performClick(View.java:<span class="number">7187</span>)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:<span class="number">7164</span>)</span><br><span class="line">  at android.view.View.access$<span class="number">3500</span>(View.java:<span class="number">813</span>)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:<span class="number">27640</span>)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:<span class="number">883</span>)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:<span class="number">100</span>)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:<span class="number">230</span>)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7725</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">526</span>)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">1034</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述日志表明，主线程正处于执行状态，看堆栈信息可知不是处于空闲状态，发生ANR是因为一处click监听函数里执行了耗时操作。</p><h2 id="主线程被锁阻塞"><a href="#主线程被锁阻塞" class="headerlink" title="主线程被锁阻塞"></a>主线程被锁阻塞</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Blocked</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x72deb848</span> self=<span class="number">0x7748c10800</span></span><br><span class="line">  | sysTid=<span class="number">22838</span> nice=-<span class="number">10</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x77cfa75ed0</span></span><br><span class="line">  | state=S schedstat=( <span class="number">390366023</span> <span class="number">28399376</span> <span class="number">279</span> ) utm=<span class="number">34</span> stm=<span class="number">5</span> core=<span class="number">1</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x7fce68b000</span>-<span class="number">0x7fce68d000</span> stackSize=8192KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.example.test.MainActivity$onCreate$<span class="number">1.</span>onClick(MainActivity.kt:<span class="number">15</span>)</span><br><span class="line">  - waiting to lock &lt;<span class="number">0x01aed1da</span>&gt; (a java.lang.Object) held by thread <span class="number">3</span> ——————关键行！！！</span><br><span class="line">  at android.view.View.performClick(View.java:<span class="number">7187</span>)</span><br><span class="line">  at android.view.View.performClickInternal(View.java:<span class="number">7164</span>)</span><br><span class="line">  at android.view.View.access$<span class="number">3500</span>(View.java:<span class="number">813</span>)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:<span class="number">27640</span>)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:<span class="number">883</span>)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:<span class="number">100</span>)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:<span class="number">230</span>)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7725</span>)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">526</span>)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">1034</span>)</span><br><span class="line">   </span><br><span class="line">  ........省略N行.....</span><br><span class="line">   </span><br><span class="line">  <span class="string">&quot;WQW TEST&quot;</span> prio=<span class="number">5</span> tid=<span class="number">3</span> TimeWating</span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x12c44230</span> self=<span class="number">0x772f0ec000</span></span><br><span class="line">  | sysTid=<span class="number">22938</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x77391fbd50</span></span><br><span class="line">  | state=S schedstat=( <span class="number">274896</span> <span class="number">0</span> <span class="number">1</span> ) utm=<span class="number">0</span> stm=<span class="number">0</span> core=<span class="number">1</span> HZ=<span class="number">100</span></span><br><span class="line">  | stack=<span class="number">0x77390f9000</span>-<span class="number">0x77390fb000</span> stackSize=1039KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Thread.sleep(Native method)</span><br><span class="line">  - sleeping on &lt;<span class="number">0x043831a6</span>&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:<span class="number">440</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x043831a6</span>&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:<span class="number">356</span>)</span><br><span class="line">  at com.example.test.MainActivity$onCreate$<span class="number">2</span>$thread$<span class="number">1.</span>run(MainActivity.kt:<span class="number">22</span>)</span><br><span class="line">  - locked &lt;<span class="number">0x01aed1da</span>&gt; (a java.lang.Object)————————————————————关键行！！！</span><br><span class="line">  at java.lang.Thread.run(Thread.java:<span class="number">919</span>)</span><br></pre></td></tr></table></figure><p>这是一个典型的主线程被锁阻塞的例子；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiting to lock &lt;<span class="number">0x01aed1da</span>&gt; (a java.lang.Object) held by thread <span class="number">3</span></span><br></pre></td></tr></table></figure><p>其中等待的锁是&lt;0x01aed1da&gt;，这个锁的持有者是线程 3。进一步搜索 “tid&#x3D;3” 找到线程3， 发现它正在TimeWating。<br>那么ANR的原因找到了：线程3持有了一把锁，并且自身长时间不释放，主线程等待这把锁发生超时。在线上环境中，常见因锁而ANR的场景是SharePreference写入。</p><h2 id="CPU被抢占"><a href="#CPU被抢占" class="headerlink" title="CPU被抢占"></a>CPU被抢占</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from 0ms to 10625ms <span class="title function_">later</span> <span class="params">(<span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">14</span>:<span class="number">38</span>:<span class="number">31.633</span> to <span class="number">2020</span>-<span class="number">03</span>-09 <span class="number">14</span>:<span class="number">38</span>:<span class="number">42.257</span>)</span>:</span><br><span class="line"><span class="number">543</span>% <span class="number">2045</span>/com.alibaba.android.rimet: <span class="number">54</span>% user + <span class="number">89</span>% kernel / faults: <span class="number">4608</span> minor <span class="number">1</span> major ————关键行！！！</span><br><span class="line"><span class="number">99</span>% <span class="number">674</span>/android.hardware.camera.provider@<span class="number">2.4</span>-service: <span class="number">81</span>% user + <span class="number">18</span>% kernel / faults: <span class="number">403</span> minor</span><br><span class="line"><span class="number">24</span>% <span class="number">32589</span>/com.wang.test: <span class="number">22</span>% user + <span class="number">1.4</span>% kernel / faults: <span class="number">7432</span> minor <span class="number">1</span> major</span><br><span class="line">........省略N行.....</span><br></pre></td></tr></table></figure><p>如上日志，第二行是钉钉的进程，占据CPU高达543%，抢占了大部分CPU资源，因而导致发生ANR。</p><p>内存紧张导致ANR<br>如果有一份日志，CPU和堆栈都很正常（不贴出来了），仍旧发生ANR，考虑是内存紧张。<br>从CPU第一行信息可以发现，ANR的时间点是2020-10-31 22:38:58.468—CPU usage from 0ms to 21752ms later (2020-10-31 22:38:58.468 to 2020-10-31 22:39:20.220)<br>接着去系统日志里搜索am_meminfo， 这个没有搜索到。再次搜索onTrimMemory，果然发现了很多条记录；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">19.749</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">37</span>:<span class="number">33.458</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">00.153</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">58.731</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br><span class="line"><span class="number">10</span>-<span class="number">31</span> <span class="number">22</span>:<span class="number">39</span>:<span class="number">02.816</span> <span class="number">20733</span> <span class="number">20733</span> E Runtime : onTrimMemory level:<span class="number">80</span>,pid:com.xxx.xxx:Launcher0</span><br></pre></td></tr></table></figure><p>可以看出，在发生ANR的时间点前后，内存都处于紧张状态，level等级是80，查看Android API 文档；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Level for &#123;<span class="doctag">@link</span> #onTrimMemory(int)&#125;: the process is nearing the end</span></span><br><span class="line"><span class="comment">* of the background LRU list, and if more memory isn&#x27;t found soon it will</span></span><br><span class="line"><span class="comment">* be killed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRIM_MEMORY_COMPLETE</span> <span class="operator">=</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure><p>可知80这个等级是很严重的，应用马上就要被杀死，被杀死的这个应用从名字可以看出来是桌面，连桌面都快要被杀死，那普通应用能好到哪里去呢？<br>一般来说，发生内存紧张，会导致多个应用发生ANR，所以在日志中如果发现有多个应用一起ANR了，可以初步判定，此ANR与你的应用无关。</p><h2 id="系统服务超时导致ANR"><a href="#系统服务超时导致ANR" class="headerlink" title="系统服务超时导致ANR"></a>系统服务超时导致ANR</h2><p>系统服务超时一般会包含BinderProxy.transactNative关键字，请看如下日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Native</span><br><span class="line">| group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> flags=<span class="number">1</span> obj=<span class="number">0x727851e8</span> self=<span class="number">0x78d7060e00</span></span><br><span class="line">| sysTid=<span class="number">4894</span> nice=<span class="number">0</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0x795cc1e9a8</span></span><br><span class="line">| state=S schedstat=( <span class="number">8292806752</span> <span class="number">1621087524</span> <span class="number">7167</span> ) utm=<span class="number">707</span> stm=<span class="number">122</span> core=<span class="number">5</span> HZ=<span class="number">100</span></span><br><span class="line">| stack=<span class="number">0x7febb64000</span>-<span class="number">0x7febb66000</span> stackSize=8MB</span><br><span class="line">| held mutexes=</span><br><span class="line">kernel: __switch_to+<span class="number">0x90</span>/<span class="number">0xc4</span></span><br><span class="line">kernel: binder_thread_read+<span class="number">0xbd8</span>/<span class="number">0x144c</span></span><br><span class="line">kernel: binder_ioctl_write_read.constprop<span class="number">.58</span>+<span class="number">0x20c</span>/<span class="number">0x348</span></span><br><span class="line">kernel: binder_ioctl+<span class="number">0x5d4</span>/<span class="number">0x88c</span></span><br><span class="line">kernel: do_vfs_ioctl+<span class="number">0xb8</span>/<span class="number">0xb1c</span></span><br><span class="line">kernel: SyS_ioctl+<span class="number">0x84</span>/<span class="number">0x98</span></span><br><span class="line">kernel: cpu_switch_to+<span class="number">0x34c</span>/<span class="number">0x22c0</span></span><br><span class="line"><span class="keyword">native</span>: #<span class="number">00</span> pc 000000000007a2ac  /system/lib64/libc.so (__ioctl+<span class="number">4</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">01</span> pc 00000000000276ec  /system/lib64/libc.so (ioctl+<span class="number">132</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">02</span> pc 00000000000557d4  /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+<span class="number">252</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">03</span> pc 0000000000056494  /system/lib64/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, <span class="type">int</span>*)+<span class="number">60</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">04</span> pc 00000000000562d0  /system/lib64/libbinder.so (android::IPCThreadState::transact(<span class="type">int</span>, unsigned <span class="type">int</span>, android::Parcel const&amp;, android::Parcel*, unsigned <span class="type">int</span>)+<span class="number">216</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">05</span> pc 000000000004ce1c  /system/lib64/libbinder.so (android::BpBinder::transact(unsigned <span class="type">int</span>, android::Parcel const&amp;, android::Parcel*, unsigned <span class="type">int</span>)+<span class="number">72</span>)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">06</span> pc 00000000001281c8  /system/lib64/libandroid_runtime.so (???)</span><br><span class="line"><span class="keyword">native</span>: #<span class="number">07</span> pc 0000000000947ed4  /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+<span class="number">196</span>)</span><br><span class="line">at android.os.BinderProxy.transactNative(Native method) ————————————————关键行！！！</span><br><span class="line">at android.os.BinderProxy.transact(Binder.java:<span class="number">804</span>)</span><br><span class="line">at android.net.IConnectivityManager$Stub$Proxy.getActiveNetworkInfo(IConnectivityManager.java:<span class="number">1204</span>)—关键行！</span><br><span class="line">at android.net.ConnectivityManager.getActiveNetworkInfo(ConnectivityManager.java:<span class="number">800</span>)</span><br><span class="line">at com.xiaomi.NetworkUtils.getNetworkInfo(NetworkUtils.java:<span class="number">2</span>)</span><br><span class="line">at com.xiaomi.frameworkbase.utils.NetworkUtils.getNetWorkType(NetworkUtils.java:<span class="number">1</span>)</span><br><span class="line">at com.xiaomi.frameworkbase.utils.NetworkUtils.isWifiConnected(NetworkUtils.java:<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>从堆栈可以看出获取网络信息发生了ANR：getActiveNetworkInfo。<br>前文有讲过：系统的服务都是Binder机制（16个线程），服务能力也是有限的，有可能系统服务长时间不响应导致ANR。如果其他应用占用了所有Binder线程，那么当前应用只能等待。<br>可进一步搜索：blockUntilThreadAvailable关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at android.os.Binder.blockUntilThreadAvailable(Native method)</span><br></pre></td></tr></table></figure><p>如果有发现某个线程的堆栈，包含此字样，可进一步看其堆栈，确定是调用了什么系统服务。此类ANR也是属于系统环境的问题，如果某类型机器上频繁发生此问题，应用层可以考虑规避策略。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://juejin.cn/post/6971327652468621326#heading-20">干货：ANR日志分析全面解析</a></li><li><a href="https://www.jianshu.com/p/30c1a5ad63a3">Android应用ANR分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓面试题</title>
      <link href="/posts/b84d2020/"/>
      <url>/posts/b84d2020/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="跨进程传递大图，你能想到哪些方案呢？"><a href="#跨进程传递大图，你能想到哪些方案呢？" class="headerlink" title="跨进程传递大图，你能想到哪些方案呢？"></a>跨进程传递大图，你能想到哪些方案呢？</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putBinder(<span class="string">&quot;binder&quot;</span>, <span class="keyword">new</span> <span class="title class_">IRemoteGetBitmap</span>.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bitmap <span class="title function_">getBitMap</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> mBitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">intent.putExtras(bundle);</span><br></pre></td></tr></table></figure><p>较大的 bitmap 直接通过 Intent 传递容易抛异常是因为 Intent 启动组件时，系统禁掉了文件描述符 fd 机制 , bitmap 无法利用共享内存，只能拷贝到 Binder 映射的缓冲区，导致缓冲区超限, 触发异常; 而通过 putBinder 的方式，避免了 Intent 禁用描述符的影响，bitmap 写 parcel 时的 allowFds 默认是 true , 可以利用共享内存，所以能高效传输图片。</p><span id="more"></span><h1 id="Android应用架构设计"><a href="#Android应用架构设计" class="headerlink" title="Android应用架构设计"></a>Android应用架构设计</h1><p><img src="/../images/r5wpOrWfFpzUz4EwIx-jIA.png" alt="r5wpOrWfFpzUz4EwIx-jIA.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bitmap全面解析</title>
      <link href="/posts/9f17da40/"/>
      <url>/posts/9f17da40/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Bitmap占用内存分析"><a href="#Bitmap占用内存分析" class="headerlink" title="Bitmap占用内存分析"></a>Bitmap占用内存分析</h1><h2 id="res中的图片大小"><a href="#res中的图片大小" class="headerlink" title="res中的图片大小"></a>res中的图片大小</h2><p><img src="/../images/1g0tcd3r383XZE9mYIrKNQ.png" alt="1g0tcd3r383XZE9mYIrKNQ.png"></p><span id="more"></span><p>上图中rodman是保存在res&#x2F;drawable-xhdpi目录下的一张600*600，大小为65Kb的图片。打印结果如下</p><blockquote><p>I&#x2F;Bitmap  ( 5673): bitmap size is 1440000</p></blockquote><p>解释</p><p>默认情况下BitmapFactory使用Bitmap.Config.ARGB_8888的存储方式来加载图片内容，而在这种存储模式下，每一个像素需要占用4个字节。因此上面图片rodman的内存大小可以使用如下公式来计算：</p><blockquote><p>宽<em>高</em> 4 &#x3D; 600 * 600 * 4 &#x3D;1440000</p></blockquote><p>但是如果我们在保证代码不修改的前提下，将图片rodman移动到（注意是移动，不是拷贝）res&#x2F;drawable-hdpi目录下，重新运行代码，则打印日志如下：</p><blockquote><p>I&#x2F;Bitmap  ( 6047): bitmap size is 2560000</p></blockquote><p>可以看出我们只是移动了图片的位置，Bitmap所占用的空间竟然上涨了77%。这是为什么呢？</p><p>实际上BitmapFactory在解析图片的过程中，会根据当前设备屏幕密度和图片所在的drawable目录来做一个对比，根据这个对比值进行缩放操作。具体公式为如下所示</p><ol><li>缩放比例scale &#x3D;当前设备屏幕密度&#x2F;图片所在drawable目录对应屏幕密度</li><li>Bitmap实际大小&#x3D;宽* scale <em>高</em> scale * Config对应存储像素数</li></ol><p>在Android中，各个drawable目录对应的屏幕密度分别为下：</p><p><img src="/../images/P2koli50g9KPTBfb87yqBA.png" alt="P2koli50g9KPTBfb87yqBA.png"></p><p>我运行的设备是Nexus 4，屏幕密度为320。如果将rodman放到drawable-hdpi目录下，最终的计算公式如下：</p><blockquote><p>rodman实际占用内存大小&#x3D; 600 * (320 &#x2F; 240) * 600 * (320 &#x2F; 240) * 4 &#x3D;2560000</p></blockquote><h2 id="assets中的图片大小"><a href="#assets中的图片大小" class="headerlink" title="assets中的图片大小"></a>assets中的图片大小</h2><p>同样是上面的rodman.png，这次将它放到assets目录中，使用如下代码加载：</p><p><img src="/../images/P2koli50g9KPTBfb87yqBA.png" alt="P2koli50g9KPTBfb87yqBA.png"></p><p>最终打印结果如下：</p><blockquote><p>I&#x2F;Bitmap  ( 5673): bitmap size is 1440000</p></blockquote><p>可以看出，加载 assets 目录中的图片，系统并不会对其进行缩放操作。</p><p>assets计算公式  </p><p>Bitmap实际大小 &#x3D; 宽 * 高 * 一像素字节数</p><h1 id="Bitmap-加载优化"><a href="#Bitmap-加载优化" class="headerlink" title="Bitmap 加载优化"></a>Bitmap 加载优化</h1><p><strong>1. 修改图片加载的Config</strong></p><p>将存储方式设置为 Bitmap.Config.RGB_565。这种存储方式一个像素占用 2 个字节，所以最终占用内存直接减半。</p><p><img src="/../images/CgqCHl7GJUyAPcYTAAHDKDnB6wE358.png" alt="CgqCHl7GJUyAPcYTAAHDKDnB6wE358.png"></p><p>打印日志如下:</p><blockquote><p>I&#x2F;Bitmap  ( 6339): bitmap size is 720000</p></blockquote><p><strong>2. inSampleSize</strong></p><p>Options 中还有一个 inSampleSize 参数，可以实现 Bitmap 采样压缩，这个参数的含义是宽高维度上每隔 inSampleSize 个像素进行一次采集。比如以下代码：</p><p><img src="/../images/Ciqc1F7GJVyActI9AAIFtHMpSCo369.png" alt="Ciqc1F7GJVyActI9AAIFtHMpSCo369.png"></p><p>因为宽高都会进行采样，所以最终图片会被缩略 4 倍，最终打印效果如下：</p><blockquote><p>I&#x2F;Bitmap  ( 6414): bitmap size is 180000   &#x2F;&#x2F; 170Kb</p></blockquote><h1 id="Bitmap复用"><a href="#Bitmap复用" class="headerlink" title="Bitmap复用"></a>Bitmap复用</h1><p>场景描述</p><p>如果在 Android 某个页面创建很多个 Bitmap，比如有两张图片 A 和 B，通过点击某一按钮需要在 ImageView 上切换显示这两张图片，实现效果如下所示：</p><p><img src="/../images/Ciqc1F7GJYyACIiCAMbF_4x1vIQ360.gif" alt="Ciqc1F7GJYyACIiCAMbF_4x1vIQ360.gif"></p><p>可以使用以下代码实现上述效果：</p><p><img src="/../images/CgqCHl7GJaqABz77AAIZRUExynU013.png" alt="CgqCHl7GJaqABz77AAIZRUExynU013.png"></p><p>但是在每次调用 switchImage 切换图片时，都需要通过 BitmapFactory 创建一个新的 Bitmap 对象。当方法执行完毕后，这个 Bitmap 又会被 GC 回收，这就造成不断地创建和销毁比较大的内存对象，从而导致频繁 GC（或者叫内存抖动）。像 Android App 这种面相最终用户交互的产品，如果因为频繁的 GC 造成 UI 界面卡顿，还是会影响到用户体验的。可以在 Android Studio Profiler 中查看内存情况，多次切换图片后，显示的效果如下：</p><p><img src="/../images/Ciqc1F7GJbGAX18WAAJGL3irS4A779.png" alt="Ciqc1F7GJbGAX18WAAJGL3irS4A779.png"></p><p><strong>使用 Options.inBitmap 优化</strong></p><p>实际上经过第一次显示之后，内存中已经存在了一个 Bitmap 对象。每次切换图片只是显示的内容不一样，我们可以重复利用已经占用内存的 Bitmap 空间，具体做法就是使用 Options.inBitmap 参数。将 getBitmap 方法修改如下：</p><p><img src="/../images/CgqCHl7GJbmAaThsAAfZxD2Nk4g697.png" alt="CgqCHl7GJbmAaThsAAfZxD2Nk4g697.png"></p><p>解释说明：</p><ol><li>图中 1 处创建一个可以用来复用的 Bitmap 对象。</li><li>图中 2 处，将 options.inBitmap 赋值为之前创建的 reuseBitmap 对象，从而避免重新分配内存。</li></ol><p>重新运行代码，并查看 Profiler 中的内存情况，可以发现不管我们切换图片多少次，内存占用始终处于一个水平线状态。</p><p><img src="/../images/Ciqc1F7GJcCARDsaAAB-hGb9K9w827.png" alt="Ciqc1F7GJcCARDsaAAB-hGb9K9w827.png"></p><p>注意：在上述 getBitmap 方法中，复用 inBitmap 之前，需要调用 canUseForInBitmap 方法来判断 reuseBitmap 是否可以被复用。这是因为 Bitmap 的复用有一定的限制：</p><ol><li>在 Android 4.4 版本之前，只能重用相同大小的 Bitmap 内存区域；</li><li>4.4 之后你可以重用任何 Bitmap 的内存区域，只要这块内存比将要分配内存的 bitmap 大就可以。</li></ol><p>canUserForInBitmap 方法具体如下：</p><p><img src="/../images/CgqCHl7GJciALgl-AAJID6lRHu4721.png" alt="CgqCHl7GJciALgl-AAJID6lRHu4721.png"></p><p>细心的你可能也发现了在每次加载之前，除了 inBitmap 参数之外，我还将 Options.inMutable 置为 true，这里如果不置为 true 的话，BitmapFactory 将不会重复利用 Bitmap 内存，并输出相应 warning 日志：</p><blockquote><p>W&#x2F;BitmapFactory: Unable to reuse an immutable bitmap as an image decoder target.</p></blockquote><h1 id="BitmapRegionDecoder-图片分片显示"><a href="#BitmapRegionDecoder-图片分片显示" class="headerlink" title="BitmapRegionDecoder 图片分片显示"></a>BitmapRegionDecoder 图片分片显示</h1><p>有时候我们想要加载显示的图片很大或者很长，比如手机滚动截图功能生成的图片。</p><p>针对这种情况，在不压缩图片的前提下，不建议一次性将整张图加载到内存，而是采用分片加载的方式来显示图片部分内容，然后根据手势操作，放大缩小或者移动图片显示区域。</p><p>图片分片加载显示主要是使用 Android SDK 中的 BitmapRegionDecoder 来实现。用下面这张图rodman3.png 举例：</p><p><img src="/../images/CgqCHl7GJdyANF1HAACsiTjhRw869.jpeg" alt="CgqCHl7GJdyANF1HAACsiTjhRw869.jpeg"></p><p><strong>BitmapRegionDecoder 基本使用</strong></p><p>首先需要使用 BitmapRegionDecoder 将图片加载到内存中，图片可以以绝对路径、文件描述符、输入流的方式传递给 BitmapRegionDecoder，如下所示：</p><p><img src="/../images/Ciqc1F7GJeeAFD6CAAFug--inhA254.png" alt="Ciqc1F7GJeeAFD6CAAFug--inhA254.png"></p><p>运行后显示效果如下：</p><p><img src="/../images/Ciqc1F7GJe2AX63nAAXfDN4qgKU233.png" alt="Ciqc1F7GJe2AX63nAAXfDN4qgKU233.png"></p><p>在此基础上，我们可以通过自定义View，添加 touch 事件来动态地设置 Bitmap 需要显示的区域 Rect。具体实现网上已经有很多成熟的轮子可以直接使用，比如 LargeImageView 。张鸿洋先生也有一篇比较详细文章对此介绍：Android 高清加载巨图方案。</p><h1 id="Bitmap-缓存"><a href="#Bitmap-缓存" class="headerlink" title="Bitmap 缓存"></a>Bitmap 缓存</h1><p>当需要在界面上同时展示一大堆图片的时候，比如 ListView、RecyclerView 等，由于用户不断地上下滑动，某个 Bitmap 可能会被短时间内加载并销毁多次。这种情况下通过使用适当的缓存，可以有效地减缓 GC 频率保证图片加载效率，提高界面的响应速度和流畅性。</p><p>最常用的缓存方式就是 LruCache，基本使用方式如下：</p><p><img src="/../images/Ciqc1F7GJfaAG6-mAAU9UuZI15w565.png" alt="Ciqc1F7GJfaAG6-mAAU9UuZI15w565.png"></p><p>这个仅做了解，图片加载库已经实现图片缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何跨App启动Activity</title>
      <link href="/posts/7b549679/"/>
      <url>/posts/7b549679/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何启动外部应用的Activity"><a href="#如何启动外部应用的Activity" class="headerlink" title="如何启动外部应用的Activity"></a>如何启动外部应用的Activity</h1><p><strong>1. 共享uid的App</strong></p><p>uid适用于全家桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;com.apkok.android&quot;</span></span><br><span class="line">    android:sharedUserId=<span class="string">&quot;com.apkok&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent().setComponent(ComponentName(<span class="string">&quot;com.apkok.app.b&quot;</span>,<span class="string">&quot;com.apkok.app.b.BActivity&quot;</span>)))</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>2. 使用exported</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AndroidManifest.xml清单文件中：</span><br><span class="line"><span class="comment">// 当exported为true的时候，这种方式是将该Activity暴露在了系统当中，随便哪个应用都可以直接访问该Activity。</span></span><br><span class="line">&lt;activity android:name=<span class="string">&quot;.BActivity&quot;</span> android:exported=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent().setComponent(ComponentName(<span class="string">&quot;com.apkok.app.b&quot;</span>,<span class="string">&quot;com.apkok.app.b.BActivity&quot;</span>)))</span><br></pre></td></tr></table></figure><p><strong>3. 使用intentFilter（隐式启动）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;.BActivity&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">&quot;com.apkok.intent.TEST&quot;</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent(<span class="string">&quot;com.apkok.intent.TEST&quot;</span>));</span><br></pre></td></tr></table></figure><h1 id="为允许外部启动的Activity加权限"><a href="#为允许外部启动的Activity加权限" class="headerlink" title="为允许外部启动的Activity加权限"></a>为允许外部启动的Activity加权限</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">App B中的Activity B:</span><br><span class="line"></span><br><span class="line">&lt;permission android:name=<span class="string">&quot;com.apkok.b&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;activity android:name=<span class="string">&quot;.BActivity&quot;</span></span><br><span class="line">    android:permission=<span class="string">&quot;com.apkok.b&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.apkok.intent.TEST&quot;</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">App A中的Activity A:</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;com.apkok.b&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin中使用</span></span><br><span class="line">startActivity(Intent(<span class="string">&quot;com.apkok.intent.TEST&quot;</span>));</span><br></pre></td></tr></table></figure><p>注意：如果通过权限的方式在App A中的Activity A来启动App B中的Activity B，需要确保App B要比App A先安装，这样的话，在App A中才可以获取到权限，反之亦然。</p><h1 id="拒绝服务漏洞"><a href="#拒绝服务漏洞" class="headerlink" title="拒绝服务漏洞"></a>拒绝服务漏洞</h1><p>场景：App A中的Activity A要启动App B中的Activity B，这样的话，Activity A就是攻击者，Activity B是受害者，在Activity B把自己暴露出来了之后，会出现什么情况呢？</p><p>假设Activity A启动Activity B的时候，传递参数的时候，往Bundle里面扔了一个SerializableA，但SerializableA这个类只在App A里面有，App B里面没有，但我们都知道Bundle在收到数据之后，只要你在Activity B里面去访问了Intent的Extras，它就一定会把里面的数据进行反序列化出来，那么在反序列化的过程当中，如果有一个它不知道的类，那就会抛出一个找不到类的异常，这就是我们通常所说的拒绝服务漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerializableA</span>: Serializable</span><br><span class="line"></span><br><span class="line"><span class="title function_">startActivity</span><span class="params">(Intent(<span class="string">&quot;com.apkok.intent.TEST.B&quot;</span>)</span>.putExtra(<span class="string">&quot;SerializableA&quot;</span>, SerializableA()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// WXEntryActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    SendAuth.<span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendAuth</span>.Resp(intent.getExtras());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码场景是：App A中的Activity A启动微信App进行微信登录授权或使用微信的一些服务的时候，微信会要求我们集成WXEntryActivity类，这个类里面有个handleIntent()方法，方法里面会调用intent.getExtras()方法，这个时候就会将我们传递过来的SerializableA进行反序列化，但在反序列化的过程中，因为微信App里没有SerializableA类，那么就会抛出一个找不到类的异常。</p><p>这种问题如何解决呢？</p><p>Activity中读取Intent的Extras的时候，使用try、catch捕获异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修改WXEntryActivity.java代码：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SendAuth.<span class="type">Resp</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendAuth</span>.Resp(intent.getExtras());</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ol><li>exported不推荐使用。</li><li>尽量不暴露Activity，为暴露的Activity加权限控制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Activity启动流程</title>
      <link href="/posts/5bb05e10/"/>
      <url>/posts/5bb05e10/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Activity跨进程启动"><a href="#Activity跨进程启动" class="headerlink" title="Activity跨进程启动"></a>Activity跨进程启动</h1><p><img src="/../images/WX20240319-103658@2x.png" alt="WX20240319-103658@2x.png"></p><span id="more"></span><h1 id="Activity进程内启动"><a href="#Activity进程内启动" class="headerlink" title="Activity进程内启动"></a>Activity进程内启动</h1><p><img src="/../images/WX20240319-103831@2x.png" alt="WX20240319-103831@2x.png"></p><h1 id="Activity参数传递"><a href="#Activity参数传递" class="headerlink" title="Activity参数传递"></a>Activity参数传递</h1><p><img src="/../images/WX20240319-111955.png" alt="WX20240319-111955.png"></p><p>同进程可以使用Model。<br>跨进程需要使用ContentProvider。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JNI如何实现数据传递？</title>
      <link href="/posts/4df65dfa/"/>
      <url>/posts/4df65dfa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java-Bitmap-和-Native-Bitmap-如何关联"><a href="#java-Bitmap-和-Native-Bitmap-如何关联" class="headerlink" title="java Bitmap 和 Native Bitmap 如何关联"></a>java Bitmap 和 Native Bitmap 如何关联</h1><ol><li>通过在Java层Bitmap.java持有的private final long mNativePtr（指针），这个mNativePtr就是Native层的Bitmap.h&#x2F;cpp的指针。通过指针关联。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java层Native方法</span></span><br><span class="line"><span class="comment">// 该方法用于压缩Bitmap到stream（流）里面。</span></span><br><span class="line"><span class="comment">// nativeBitmap是指针，对应的底层Native函数中的bitmapHandle参数，然后在底层函数中使用bitmapHandle传入到bitmap(bitmapHandle)函数中，获取到对应的底层Bitmap对象，获取到之后就可以操作底层的Bitmap了。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">nativeCompress</span><span class="params">(<span class="type">long</span> nativeBitmap, <span class="type">int</span> format, <span class="type">int</span> quality, OutputStream stream, <span class="type">byte</span>[] tempStorage)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层Native函数</span></span><br><span class="line"><span class="keyword">static</span> jboolean <span class="title function_">Bitmap_compress</span><span class="params">(JNIEnv* env, jobject clazz, jlong bitmapHandle, jint format, jint quality, jobject jstream, jbyteArray jstorage)</span> &#123;</span><br><span class="line">LocalScopeBitmap <span class="title function_">bitmap</span><span class="params">(bitmapHandle)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="DirectBuffer"><a href="#DirectBuffer" class="headerlink" title="DirectBuffer"></a>DirectBuffer</h1><p>DirectBuffer是直接在物理内存上开辟了一块空间，所以对于Java虚拟机来说，可以直接读写它，对于Native层也可以直接读写它，这样的话，就不需要拷贝了，而且拷贝也是需要成本的。</p><p>如下代码所示：</p><p>在Jave层直接往ByteBuffer里面写了一串数值比如1 2 3 4 5 6，在Native层可以直接读，但是要注意字节序的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java虚拟机（ByteBuffer）</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">100</span>);</span><br><span class="line">buffer.putInt(...);</span><br><span class="line">buffer.flip();</span><br><span class="line">NativeCInf.useDirectBuffer(buffer, buffer.limit());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* bufPtr = (<span class="type">int</span>*)env-&gt;GetDirectBufferAddress(buf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; length / sizeof(<span class="type">int</span>); i++) &#123;</span><br><span class="line">    <span class="comment">// bufPtr[i]，此处要注意字节序的问题</span></span><br><span class="line">    LOGI(<span class="string">&quot;useArray: %d&quot;</span>, bufPtr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.cnblogs.com/pengxurui/p/16584683.html">图片系列（6）不同版本上 Bitmap 内存分配与回收原理对比 </a></li><li><a href="https://blog.csdn.net/u011082160/article/details/97912349">Adnroid jni数据传递大全,看这篇就够了</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java的Native方法与底层Native函数是怎么绑定的？</title>
      <link href="/posts/2cc69b3b/"/>
      <url>/posts/2cc69b3b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>静态绑定：通过命名规则映射。<br>动态绑定：通过JNI函数注册。</p><p><img src="/../images/WX20240318-152749.png" alt="WX20240318-152749.png"></p><p>建议通过动态绑定。</p><span id="more"></span><h1 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.apkok.nativec;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeCInf</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">callNativeStatic</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------JNI-------------------</span><br><span class="line"></span><br><span class="line">extern <span class="string">&quot;C&quot;</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line"><span class="comment">// 命名规则：Java_包路径（.统一改为_）_类名_方法名</span></span><br><span class="line"><span class="comment">// 方法参数：</span></span><br><span class="line"><span class="comment">// 1、如果Java Native方法是静态的，对应的底层Native函数的参数就是jclass</span></span><br><span class="line"><span class="comment">// 2、如果Java Native方法是非静态的，对应的底层Native函数的参数就是jobject</span></span><br><span class="line">Java_io_github_apkok_nativec_NativeCInf_callNativeStatic(JNIEnv *,jclass)</span><br></pre></td></tr></table></figure><h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include <span class="string">&quot;log.hpp&quot;</span></span><br><span class="line"> </span><br><span class="line">extern <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"> </span><br><span class="line">    jstring <span class="title function_">stringFromJNI</span><span class="params">(JNIEnv *env, jobject instance)</span> &#123;</span><br><span class="line">        std::<span class="type">string</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    jint <span class="title function_">add</span><span class="params">(JNIEnv *env, jclass clazz, jint a, jint b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    jint <span class="title function_">RegisterNatives</span><span class="params">(JNIEnv *env)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、获取Class</span></span><br><span class="line">        <span class="type">jclass</span> <span class="variable">clazz</span> <span class="operator">=</span> env-&gt;FindClass(<span class="string">&quot;com/afei/jnidemo/MainActivity&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (clazz == NULL) &#123;</span><br><span class="line">            LOGE(<span class="string">&quot;con&#x27;t find class: com/afei/jnidemo/MainActivity&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        JNINativeMethod methods_MainActivity[] = &#123;</span><br><span class="line">                &#123;<span class="string">&quot;stringFromJNI&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="keyword">void</span> *) stringFromJNI&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;add&quot;</span>,           <span class="string">&quot;(II)I&quot;</span>,                (<span class="keyword">void</span> *) add&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// int len = sizeof(methods_MainActivity) / sizeof(methods_MainActivity[0]);</span></span><br><span class="line">        <span class="comment">// 2、注册方法</span></span><br><span class="line">        <span class="keyword">return</span> env-&gt;RegisterNatives(clazz, methods_MainActivity,</span><br><span class="line">                                    sizeof(methods_MainActivity) / sizeof(methods_MainActivity[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> &#123;</span><br><span class="line">        JNIEnv *env = NULL;</span><br><span class="line">        <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">jint</span> <span class="variable">result</span> <span class="operator">=</span> RegisterNatives(env);</span><br><span class="line">        LOGD(<span class="string">&quot;RegisterNatives result: %d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>动态绑定可以在任何时刻触发</li><li>动态绑定之前根据静态规则查找Native函数</li><li>动态绑定可以在绑定后的任意时刻取消</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><img src="/../images/WX20240318-153132.png" alt="WX20240318-153132.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPU架构适配</title>
      <link href="/posts/2b96b6af/"/>
      <url>/posts/2b96b6af/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="不同CPU架构之间的兼容性"><a href="#不同CPU架构之间的兼容性" class="headerlink" title="不同CPU架构之间的兼容性"></a>不同CPU架构之间的兼容性</h1><ol><li>x86其实是可以在x86_64机器上跑的，所以x86_64兼容x86。 </li><li>armeabi-v7a其实是可以在arm64-v8a机器上跑的，所以arm64_v8a兼容armeabi-v7a。 </li><li>armeabi其实是可以在x86_64、x86、arm64-v8a、armeabi-v7a机器上跑的，所以x86_64、x86、arm64-v8a、armeabi-v7a兼容armeabi。</li></ol><p><img src="/../images/WX20240318-122047.png" alt="WX20240318-122047.png"></p><span id="more"></span><p>例子：</p><p>项目中的libs目录下有以下so库：armeabi（libmath.so、libui.so）、armeabi-v7a（libmath.so、libui.so）、arm64-v8a（libmath.so、libui.so），那么在arm64-v8a的机器上Native库如何加载呢？</p><p>它会优先选择当前CPU对应的CPU架构目录下的so库，也就是会加载arm64-v8a（libmath.so、libui.so）目录下的so库，假设如果arm64-v8a架构的so库里面没有libui.so了，那么会发生什么问题呢？它还是会去arm64-v8a架构的so库里面找，但发现so库里没有libui.so，那么加载就会失败，那刚刚也说了armeabi和armeabi-v7a本身就兼容arm64-v8a，那为什么不去加载它们呢？这是因为CPU加载so库的时候就这么规定的，所以要提供so库就一定要提供一全套，要么就一个都不要提供，这样CPU就会去找它所兼容的so库。</p><h1 id="兼容模式的问题"><a href="#兼容模式的问题" class="headerlink" title="兼容模式的问题"></a>兼容模式的问题</h1><p>1、兼容模式运行的Native库无法获得最优性能（所以x86的电脑上运行arm的虚拟机会很慢！）<br>2、兼容模式容易出现一些难以排查的内存问题<br>3、系统优先加载对应架构目录下的so库</p><h1 id="so库太多如何优化Apk体积"><a href="#so库太多如何优化Apk体积" class="headerlink" title="so库太多如何优化Apk体积"></a>so库太多如何优化Apk体积</h1><h2 id="为App提供不同的CPU架构的Native库"><a href="#为App提供不同的CPU架构的Native库" class="headerlink" title="为App提供不同的CPU架构的Native库"></a>为App提供不同的CPU架构的Native库</h2><p>实际开发过程中，我们不可能提供所有CPU架构的so库，那就要考虑兼容，兼容性最好的当然就是armeabi了，那是不是我们就只需要提供这一套了呢？如果在性能不敏感且无运行时异常的情况下可以这么干。但目前市场上大部分的机器的CPU架构都已经是armeabi-v7a和arm64-v8a了，所以这个时候提供一套兼容性最好的so库就是armeabi-v7a了，所以我们要结合目标用户群体提供合适的架构。</p><p>还有一个方案就是，我们只提供一个CPU架构目录，比如armeabi-v7a，把所需要的so库都扔到这一个目录里面，这样一来里面也可以提供arm64-v8a的so库等，这样的话，我们就可以动态根据当前的CPU架构去选择加载一些特定的so库，微信就是这么干的。</p><p>那到底选择那种方案去提供so库呢？</p><p>最好的办法就是通过线上监控问题，然后针对性提供Native库。</p><p><img src="/../images/WX20240318-143320.png" alt="WX20240318-143320.png"></p><p>对待libmath.so 对性能要求比较高，可以同事提供v7和v8两个。</p><h2 id="优化so体积"><a href="#优化so体积" class="headerlink" title="优化so体积"></a>优化so体积</h2><ol><li>默认隐藏所有符号，只公开必要的（-fvisibility&#x3D;hidden）</li><li>禁用C++ Exception&amp;RTTI（-fno-exception -fno-rtti）</li><li>不要使用iostream，应优先使用Android Log</li><li>使用gc-sections去除无用代码（类似于Java的混淆） LOCAL_CFLAGS +&#x3D; -ffunction-sections -fdata-sections  LOCAL_LDFLAGS +&#x3D; -Wl,–gc-sections</li></ol><h1 id="构建时分包"><a href="#构建时分包" class="headerlink" title="构建时分包"></a>构建时分包</h1><p>根据CPU架构进行分包，每一个包里面只包含一种CPU架构，然后借助应用市场按CPU架构分发安装包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">splits &#123;</span><br><span class="line">    abi &#123;</span><br><span class="line">        enable true</span><br><span class="line">        reset()</span><br><span class="line">        include &quot;armeabi-v7a&quot;、&quot;arm64-v8a&quot;、&quot;x86&quot;、&quot;x86_64&quot;</span><br><span class="line">        universalApk true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SDK开发者应当提供哪些so库"><a href="#SDK开发者应当提供哪些so库" class="headerlink" title="SDK开发者应当提供哪些so库"></a>SDK开发者应当提供哪些so库</h1><ol><li>尽量不在Native层开发，降低问题跟踪维护成本</li><li>尽量优化Native库的体积，降低开发者的使用成本</li><li>必须提供完整的CPU架构依赖</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/posts/7678a22a/"/>
      <url>/posts/7678a22a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="泛型擦除的好处"><a href="#泛型擦除的好处" class="headerlink" title="泛型擦除的好处"></a>泛型擦除的好处</h1><ol><li>运行时内存负担小</li><li>为了向前兼容</li></ol><span id="more"></span><h1 id="类型擦除有哪些问题"><a href="#类型擦除有哪些问题" class="headerlink" title="类型擦除有哪些问题"></a>类型擦除有哪些问题</h1><p><strong>1. 基本类型无法作为泛型参数，会有装箱开箱性能损耗。</strong><br><strong>2. 泛型类型无法用作方法重载。</strong></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 泛型类型无法当做真实类型使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">genericMethod</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">newInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(); <span class="comment">// 错误</span></span><br><span class="line">    T[] arrray = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">0</span>];  <span class="comment">// 错误 </span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> T.class; <span class="comment">// 错误</span></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(); <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">if</span>(list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123; <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 泛型擦除后，无法知道要转换的类型，需要参数传入（Class<T> classOfT）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">fromJson</span><span class="params">(String json, Class&lt;T&gt; classOfT)</span> <span class="keyword">throws</span> JsonSyntaxException &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> fromJson(json, TypeToken.get(classOfT));</span><br><span class="line">    <span class="keyword">return</span> Primitives.wrap(classOfT).cast(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 静态类型无法引用类泛型参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">max</span><span class="params">(T a, T b)</span>&#123;&#125; <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; R <span class="title function_">max</span><span class="params">(R a, R b)</span>&#123;&#125; <span class="comment">// 正确 声明泛型参数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="签名信息"><a href="#签名信息" class="headerlink" title="签名信息"></a>签名信息</h1><ol><li>可以通过签名信息获取泛型类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, Integer&gt;&gt; <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> SubClass.class.getMethod(<span class="string">&quot;getValue&quot;</span>).getGenericReturnType();</span><br><span class="line"><span class="keyword">for</span> (Type type : parameterizedType.getActualTypeArguments()) &#123;</span><br><span class="line">    System.out.printf(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>混淆时保留签名信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes Signature</span><br></pre></td></tr></table></figure><ol start="3"><li>使用泛型签名的两个实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">collectionType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;Collection&lt;Integer&gt;&gt;()&#123;&#125;.getType();</span><br><span class="line">Collection&lt;Integer&gt; inits = gson.fromJson(json, collectionType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GitHubService</span> &#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; <span class="title function_">listRepos</span><span class="params">(<span class="meta">@Path(&quot;user&quot;)</span> String user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类</title>
      <link href="/posts/a61b637d/"/>
      <url>/posts/a61b637d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>匿名内部类没有单独的类定义，它在创建对象的同时定义类。</p><span id="more"></span><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(参数列表) &#123;</span><br><span class="line">   <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口() &#123;</span><br><span class="line">   <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类是与new关联的，在创建对象的时候定义类，new后面是父类或者父接口，然后是圆括号()，里面可以是传递给父类构造方法的参数，最后是大括号{}，里面是类的定义。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>)&#123;                </span><br><span class="line">            <span class="meta">@Override</span>                              </span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;             </span><br><span class="line">                <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(x,y));     </span><br><span class="line">            &#125;                                      </span><br><span class="line">        &#125;;                                       </span><br><span class="line">        System.out.println(p.distance());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Point对象的时候，定义了一个匿名内部类，这个类的父类是Point，创建对象的时候，给父类构造方法传递了参数2和3，重写了distance()方法，在方法中访问了外部方法final参数x和y。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>每个匿名内部类也都被生成为了一个独立的类，只是类的名字以外部类加数字编号，没有有意义的名字。上例中，产生了两个类Outer和Outer$1，代码大概如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$1</span>(<span class="built_in">this</span>,<span class="number">2</span>,<span class="number">3</span>,x,y);                                            </span><br><span class="line">        System.out.println(p.distance());        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">    <span class="type">int</span> y2;</span><br><span class="line">    Outer outer;</span><br><span class="line">    </span><br><span class="line">    Outer$<span class="number">1</span>(Outer outer, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)&#123;</span><br><span class="line">        <span class="built_in">super</span>(x1,y1);</span><br><span class="line">        <span class="built_in">this</span>.outer = outer;</span><br><span class="line">        <span class="built_in">this</span>.x2 = x2;</span><br><span class="line">        <span class="built_in">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>                              </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;             </span><br><span class="line">        <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="built_in">this</span>.x2,y2));     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>匿名内部类能做的，方法内部类都能做。但如果对象只会创建一次，且不需要构造方法来接受参数，则可以使用匿名内部类，代码书写上更为简洁。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>匿名内部类的构造方法由编译器生成。</p><p><strong>类型一</strong></p><ol><li>匿名内部类所在的方法 是非静态方法， 会引用自己的外部类实例。</li><li>匿名内部类的父类非静态，会引用匿名内部类的父类。</li></ol><p><img src="/../images/b934c4c248844d358b39c042c2c7cf70~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="b934c4c248844d358b39c042c2c7cf70~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><strong>类型二</strong></p><ol><li>必须是final,防止局部变量被修改，造成和匿名内部类的不一致。</li></ol><p><img src="/../images/635bd5f22c2b48868ac412035da23947~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="635bd5f22c2b48868ac412035da23947~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><strong>类型三</strong></p><ol><li>interface跟静态内部类的效果是差不多的， 就是静态的， 也就是不会去引用其外部类的实例。</li></ol><p><img src="/../images/04247078898049c2bb379eed1d792c62~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="04247078898049c2bb379eed1d792c62~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><strong>类型四</strong></p><ol><li>当匿名内部类所在的方法是静态的， 则其构造方法的参数中， 不存在所在方法的最外部类实例了。</li></ol><p><img src="/../images/2171440520f74abdb4da4e2c529379fa~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="2171440520f74abdb4da4e2c529379fa~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><h1 id="Lambda转换（SAM类型）"><a href="#Lambda转换（SAM类型）" class="headerlink" title="Lambda转换（SAM类型）"></a>Lambda转换（SAM类型）</h1><p>一个接口，只有一个抽象方法时，可以用Lambda表达式替换实现；</p><p><img src="/../images/8eb3d7f3f6664a0c80d8167357bd706d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="8eb3d7f3f6664a0c80d8167357bd706d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p><p><img src="/../images/22ae680538d54dccbca8b44204eb8f4d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png" alt="22ae680538d54dccbca8b44204eb8f4d~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程技能目标</title>
      <link href="/posts/2461e87f/"/>
      <url>/posts/2461e87f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编程语言功底"><a href="#编程语言功底" class="headerlink" title="编程语言功底"></a>编程语言功底</h1><ol><li>你熟悉的语言有哪些亮点特性？</li><li>你能运用这些特性写什么框架？</li></ol><h1 id="android系统原理"><a href="#android系统原理" class="headerlink" title="android系统原理"></a>android系统原理</h1><ol><li>程序是怎么运行的？</li><li>窗口是怎么显示的？</li><li>声音是怎么播放的？</li></ol><span id="more"></span><h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><ol><li>有哪些难点是如何突破的？</li><li>有哪些你失败之处？</li></ol><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><ol><li>为什么选这个方案？</li><li>如何进行模块边界的划分？</li><li>如何实现模块解耦？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-03日记</title>
      <link href="/posts/87043860/"/>
      <url>/posts/87043860/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="23bfbbfa9cc86c4e5f424c41b63350dbdda3df57b4faa6045f4c40a2c32fd432">026422d16125c0ef5486e4aca3c5daf506eac8b704d20a3e10d8dbe17b8641d586f098f2562ff378c8eaefc40cd08645fcb781c0c27175247887a8fa63710904c5fb41cc2077160fcb551c7176b562e7f0b1d3a29e848d56e354e3210cfad118b2029c1e8a692a35b614a0c9f658fa58fea90d31e7290f42931238ec4b8ecacbf28732c97ffd1f634c82720f065aa369dda264374aa10d648358b07e415b465fa735ba3ad5f3c0dcb85a1da85c1629e757cf15c3aa70d7f2ede01d21306263745580f3ddb8adfdad4df15f8cd5a62dab5e7c6f41e20fa5320c43849bdb753f9763c977dea3be64793cfc8531e8cfcdebb48b75cb7271c56e6cb50879639706c8388a3b0edddd2199ea3399c82d63ab0306e415fd7446922e29152cfbf7b64d27a20c2d769dea5addcdb94d86eb1b0ffe37de7cc87b334322a8a2c602034b08fbce353210b05e9ff059f7aff2ba5be527a57163e85780c3d100ea67365305dea40d48beaa960a54d4ea9ae0facc13b153</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/posts/af3eed3c/"/>
      <url>/posts/af3eed3c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认识HTTP"><a href="#认识HTTP" class="headerlink" title="认识HTTP"></a>认识HTTP</h1><ol><li>超文本传输协议 HyperText Transfer Protocol</li><li>最初目的：提供一种发送和接收HTML页面的方法</li><li>版本：HTTP 0.9、1.0、1.1、2.0、3.0</li><li>基于TCP协议</li><li>请求前需要建立TCP连接</li><li>是一个请求响应协议</li><li>客户端发送请求，服务端接收请求，给出响应。</li></ol><span id="more"></span><p><img src="/../images/WX20240307-194042.png" alt="WX20240307-194042.png"></p><h1 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h1><ol><li>使用HTTP协议需要遵守HTTP协议的报文格式</li><li>HTTP协议分为请求报文和响应报文</li><li>请求报文和响应报文分别有自己的格式</li><li>HTTP协议首部采用ASCII编码</li></ol><p>请求报文格式</p><p><img src="/../images/WX20240307-202718.png" alt="WX20240307-202718.png"></p><p>响应报文格式</p><p><img src="/../images/WX20240307-202801.png" alt="WX20240307-202801.png"></p><h1 id="字符集和编码"><a href="#字符集和编码" class="headerlink" title="字符集和编码"></a>字符集和编码</h1><ol><li>将所有需要转换的字符列出来，编上号，形成一张表，就是字符集。</li><li>依据字符集，采用一定的规则，将字符转换成二进制的0和1，就是编码。</li><li>各国家都有自己的字符集和编码，比如GB2312，GBK，big5</li><li>有些编码会兼容ASCII 码，但互相不兼容</li><li>国际上有统一的字符集，如Unicode字符集</li><li>Unicode字符集将全世界所有需要用到的字符列出来，并编号</li><li>可以采用定长编码，将Unicode编号转换成二进制</li><li>使用固定2字节来编码，可能不够用</li><li>使用固定4字节来编码，够用了，但是编码太占用空。</li><li>还可以采用可变长编码，不是直接将Unicode编号转换为二进制</li><li>UTF-8是一种可变长编码</li><li>UTF-8将Unicode 字符集分成4个区间</li><li>0000 0000-0000 007F | 0xxxxxxx</li><li>0000 0080-0000 07FF | 110xxxxx 10xxxxxx</li><li>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</li><li>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</li></ol><p>UTF-8 编码</p><p><img src="/../images/WX20240307-213907.png" alt="WX20240307-213907.png"></p><p>ASCII 编码</p><ol><li>ASCII编码规则很简单</li><li>直接使用字符编号的二进制形式</li><li>H的编号是48（hex）</li><li>i的编号是69（hex）</li><li>Hi的ASCII的编码就是 48 69</li></ol><p><img src="/../images/ascii-1-1.png" alt="ascii-1-1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络分层体系结构</title>
      <link href="/posts/7eb7b9d8/"/>
      <url>/posts/7eb7b9d8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h1><p><img src="/../images/tcpip.png" alt="tcpip.png"></p><span id="more"></span><p><img src="/../images/xrrplcn7zy.webp" alt="xrrplcn7zy.webp"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><ol><li>物理层为上一层数据链路层提供比特流传输服务。</li><li>发送方物理层把0和1在传输介质上用波的形式传输出去。</li><li>接收方物理层按照约定从波形中还原出0和1。</li></ol><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>链路（Link）：从一个节点到相邻节点的一段物理线路（有线或无线），中间没有任何其他的交换节点（主要指路由器）</p><p>数据链路层解决数据包在一个网络或一段链路上传输的问题，主要靠MAC地址。</p><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><ol><li>MAC 地址也叫物理地址，（它是一个用来确认网络设备位置的地址），6字节，是用来唯一标识主机和路由器接口的。</li><li>MAC 地址存在于主机的网卡和者路由器的接口中，全球唯一。</li><li>FF-FF-FF-FF-FF-FF 是广播MAC地址。</li><li>接收端网卡从数据链路层首部拿出目的MAC地址判断是否发给自己。</li></ol><h2 id="数据链路层帧格式"><a href="#数据链路层帧格式" class="headerlink" title="数据链路层帧格式"></a>数据链路层帧格式</h2><p><img src="/../images/ce1c3125a4cf4b57a23da3cc09603f24.png" alt="ce1c3125a4cf4b57a23da3cc09603f24.png"></p><p>类型：标识数据部分使用的是什么协议，比如IP<br>FCS：用于检测帧在传输中是否出现了误码（比特差错）</p><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ol><li>使用集线器可以把多台主机连接在一起</li><li>集线器只工作在物理层</li><li>集线器的每个端口仅简单的转发比特</li><li>每次发送消息，同一网段内所有主机都会收到</li></ol><h2 id="集线器和交换机"><a href="#集线器和交换机" class="headerlink" title="集线器和交换机"></a>集线器和交换机</h2><p><img src="/../images/WX20240301-220916.png" alt="WX20240301-220916.png"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><ol><li>网络号相同的主机或路由器接口就处于同一网段或同一个局域网中。</li><li>局域网之间通过路由器相连，形成互联网。</li><li>因特网（Internet）就是最大的互联网。</li></ol><h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p><img src="/../images/v2-13c1daebb7b5706a847f4e727d9dacde_r.jpg" alt="v2-13c1daebb7b5706a847f4e727d9dacde_r.jpg"></p><ol><li>只有A，B，C类地址可以分配给网络中的主机或路由器的各接口</li><li>主机号 “全0” 的地址是网路地址，不能分配主机或路由器的各接口</li><li>主机号 “全1” 的地址是广播地址，不能分配主机或路由器的各接口</li><li>A类地址网络号0和127不能分配</li></ol><p>问题：<br>IP地址的分类方式不够灵活，容易造成大量IP地址浪费，因为此时IP地址的网络号和主机号是固定位数的。</p><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><ol><li>从主机号中借用一些比特位作作为子网号划分出不同的子网</li><li>可以使用子网掩码标识出子网的网络号和主机号分别有多少位</li><li>子网掩码：坐起连续的1对应IP中的网络号和子网号，之后的0对应主机号</li><li>将IP地址与对应的子网掩码按位与，就能得到该IP的网络地址</li></ol><p><img src="/../images/WX20240303-141906.png" alt="WX20240303-141906.png"></p><p>默认子网掩码是指在未划分子网的情况下使用的子网掩码</p><ol><li>A类地址 255.0.0.0</li><li>B类地址 255.255.0.0</li><li>C类地址 255.255.255.0</li></ol><p><img src="/../images/WX20240303-143123.png" alt="WX20240303-143123.png"></p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><ol><li>仅从IP地址无法知道网络号和主机号，还需要子网掩码的配合</li><li>可以使用CIDR简化IP和子网掩码的表达</li><li>CIDR：无分类域间路由选择 Classless Inter-Domain-Routing</li><li>消除了A类B类C类地址的概念</li><li>消除了划分子网的概念</li></ol><p>IP：200.10.0.10<br>子网掩码：255.255.255.128<br>CIDR：200.40.0.10&#x2F;25</p><h2 id="同一网络的判断"><a href="#同一网络的判断" class="headerlink" title="同一网络的判断"></a>同一网络的判断</h2><ol><li>通信时，发送方主机用自己的IP地址和自己的子网掩码按位与</li><li>发送方主机再用目的主机的IP地址和自己的子网掩码按位与</li><li>判断目的主机是否与自己在同一网络&#x2F;段</li><li>如果目的主机与自己在同一网络，可以直接向目的主机发送消息</li><li>如果目的主机和自己不在同一网络，需要将消息发送到网关（路由器）</li></ol><h2 id="公网IP和私网IP"><a href="#公网IP和私网IP" class="headerlink" title="公网IP和私网IP"></a>公网IP和私网IP</h2><ol><li>为了缓解IP地址不够用的问题</li><li>公网IP：主要用于局域网，一般各不相同</li><li>私网IP：主要用于局域网，不同网络可以相同</li></ol><p><img src="/../images/v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp" alt="v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp"></p><p><img src="/../images/v2-e2c3a9e6015673ae21920eeeb98aa9c2_720w.webp" alt="v2-e2c3a9e6015673ae21920eeeb98aa9c2_720w.webp"></p><p><img src="/../images/WX20240303-154447.png" alt="WX20240303-154447.png"></p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><ol><li>网络地址转换 Network Address Translation</li><li>在私有网络连接到互联网的路由器上安装NAT软件，称为NAT路由器</li><li>NAT路由器至少有一个有效的公网IP</li><li>NAT路由器会建立公网IP和私有IP的对应关系表</li><li>所有私有网络的主机在和外部通信时，会在NAT路由器上转换成公网IP</li></ol><p>NAT表</p><p><img src="/../images/v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp" alt="v2-fc55e7f0cf24786125ef2000b48259b5_720w.webp"></p><h2 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h2><ol><li>网络地址与端口号转换 Network Address Port Translation</li><li>将NAT转换和运输层端口号结合使用</li><li>使用私有网络的大量主机，可以公用NAPT路由器上1个全球IP地址</li><li>NAPT路由器会建立公网IP 端口号和私有IP 端口号的对应关系表</li><li>所有私有网络的主机在和外部通信时，会在NAPT路由器上转换成公网IP</li></ol><p>NAPT表</p><p><img src="/../images/WX20240303-155943.png" alt="WX20240303-155943.png"></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP协议的首部格式</p><p><img src="/../images/20171209220259773.png" alt="20171209220259773.png"></p><ol><li>版本：IP协议的版本，一般是版本4</li><li>首部长度：协议首部长度，乘4才是最终长度</li><li>总长度：首部+数据部分长度</li><li>标识：帧的数据部分不超过1500B，过大的IP数据包需要分片，再交给数据链路层，同一数据包的所有分片标识都是一样的。</li><li>标志：是否允许分片，是否是最后一个分片</li><li>片偏移：每一片相对于原数据的字节偏移</li><li>生存时间：路由器收到待转发的IP数据包时，将其首部中的该字段的值减一，若结果不为0就转发，否则就丢弃。</li><li>协议：指明IP数据包的数据载荷是何种协议数据单元。</li><li>首部校验和：用于检测在传输过程中IP首部是否出现了差错。</li><li>填充：使其首部协议长度为4的倍数。</li></ol><p><img src="/../images/WX20240303-181227.png" alt="WX20240303-181227.png"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><ol><li>地址解析协议 Address Resolution Protocol</li><li>通过IP地址获取MAC地址</li><li>同一网络中的主机或路由器接口之间才能使用ARP获取MAC地址。</li><li>主机或路由器拿到目的主机的MAC地址后，会记录在自己的ARP缓存中</li><li>每次通信前都会查看自己的ARP表，没有找到，才会再次发送ARP请求</li></ol><p><img src="/../images/download.png" alt="download.png"></p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><ol><li>网际控制报文协议 Internet Control Message Protocol</li><li>主机或路由器使用ICMP来发送 询问报文和差错报告报文</li><li>常见的询问报文有两种：回送请求和回答，时间戳请求和回答</li><li>ICMP是网络层协议</li><li>ICMP报文被封装在IP数据报中发送</li><li>ICMP报文作为IP数据报的数据载荷</li><li>协议的数据载荷并不一定都是从上一层来的，有的没有上一层</li></ol><p>IMCP 询问报文-回送请求和回答</p><ol><li>由主机或路由器向一个特定的目的的主机或者路由器发出</li><li>收到次报文的主机或路由器必须发送ICMP回送回答报文</li><li>这种询问报文用来测试目的站是否可达以及了解其有关状态</li><li>ping命令使用的就是ICMP询问报文</li></ol><p>ICMP 差错报告报文</p><ol><li>用来向主机或路由器报告差错情况</li><li>常见的差错有：终点不可达，超时等</li><li>tracert命名用于检测IP数据报从源主机到达目的主机要经过哪些路由器</li><li>tracert使用ICMP报文类型有询问报文以及差错报告报文</li></ol><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ol><li>一种具有多个输入端口和输出端口的专用计算机</li><li>在不同网络之间转发数据</li><li>不同网络之间的主机通信，需要路由器</li><li>默认情况下，路由器只知道跟它直连的网络怎么走</li><li>非直连网络需要通过配置静态（手动）或 动态路由（协议）的方式告诉它</li><li>路由表用来记录如何到达某个网络</li><li>数据到来时，路由器会取出目的主机的IP地址</li><li>根据自身的路由表，决定从哪个端口转发出去</li><li>路由器是三层设备（网络层设备）</li></ol><p><img src="/../images/WX20240304-145443.png" alt="WX20240304-145443.png"></p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><ol><li>前三层解决了数据从主机到主机的问题</li><li>实际进行通信的真正实体，是位于通信两端主机的进程</li><li>运输层协议解决数据从进程到进程的问题</li></ol><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ol><li>如何标识不同的应用进程呢</li><li>使用端口号来表示和区分不同的进程</li><li>操作系统会记录各个进程占用（监听）的端口号</li><li>端口号的长度为16比特，取值范围是0-65535</li></ol><p>端口号分类</p><p><img src="/../images/WX20240304-212439.png" alt="WX20240304-212439.png"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><img src="/../images/WX20240304-213826.png" alt="WX20240304-213826.png"></p><p><img src="/../images/2218033471-5cc81004c4449.webp" alt="2218033471-5cc81004c4449.webp"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ol><li>传输控制协议 Transmission Control Protocol</li><li>提供面向连接的可靠传输服务</li><li>传输之前需要先建立连接，传输后需要释放连接</li><li>出现误码，丢失现象会要求重传，重复的会丢弃，乱序数据也会被正确重组</li><li>一般用于可靠传输的应用，例如文件，邮件传输</li><li>TCP是面向字节流的</li><li>会给要传输数据的每一个字节都编号</li></ol><h2 id="TCP协议的可靠传输"><a href="#TCP协议的可靠传输" class="headerlink" title="TCP协议的可靠传输"></a>TCP协议的可靠传输</h2><p><img src="/../images/WX20240305-221315.png" alt="WX20240305-221315.png"></p><p><img src="/../images/WX20240305-221859.png" alt="WX20240305-221859.png"></p><p><img src="/../images/WX20240305-222156.png" alt="WX20240305-222156.png"></p><h2 id="TCP协议首部格式"><a href="#TCP协议首部格式" class="headerlink" title="TCP协议首部格式"></a>TCP协议首部格式</h2><p><img src="/../images/1.png" alt="1.png"></p><p>TCP首部包括20字节的固定首部部分和扩展首部（选项 + 填充），扩展首部最大40字节。<br>20个字节又分为5部分，每部分4个字节32位，如图中的5行，每行表示32位。</p><ol><li>序号：指出本TCP数据载荷第一个字节的序号。</li><li>确认号：对之前收到的所有字节的确认，同时指出期望收到对方下一个TCP数据载荷的第一个字节的序号。比如收到1-5字节的数据，会返回6。</li><li>ACK：只有当ACK为1时，确认号字段才有效。</li><li>数据偏移：指出TCP数据部分的起始处偏移TCP起始处有多远，其实就是TCP的首部长度需乘4</li><li>SYN：用于TCP “三次握手” 建立连接， &#x3D; 1时表明这是一个TCP连接报文</li><li>FIN：用于TCP “四次挥手”释放连接， &#x3D; 1 时表明此TCP的发送方已经将全部数据发送完毕，要求释放TCP连接。</li><li>PSH：推送标志位，提醒接收方取走接受缓冲区的数据</li><li>RST：用于复位TCP连接，&#x3D; 1时表明TCP连接出现严重差错，必须释放连接，让后重新建立连接。</li><li>URG：紧急标志位， &#x3D; 1时，紧急指针字段才有效。</li><li>窗口：用来让对方设置发送窗口的大小，单位为字节。</li><li>紧急指针：指出本TCP数据部分包含了多长的紧急数据，紧急数据之后是普通数据。</li><li>扩展首部：一些扩展功能，如选择确认，窗口扩大，MSS等，填充保证首部长度能被4整除。</li></ol><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ol><li>当发送方发送数据太快，接收方来不及接收，会造成接收方缓存溢出</li><li>接收方会通过TCP报文段的 “窗口” 字段告诉发送方调整发送窗口</li><li>接收方酌情调整发送窗口</li><li>发送窗口&#x3D; min（拥塞窗口，接收窗口）</li></ol><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ol><li>网络中的链路或路由器过载时，会丢弃数据包，这种情况就是网络拥塞</li><li>为了避免拥塞，TCP采用拥塞控制</li><li>拥塞控制采用一系列方法控制拥塞窗口的大小，进而控制发送窗口的大小</li></ol><h2 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h2><ol><li>SYN表示请求建立连接，</li><li>ACK表示响应</li></ol><p><img src="/../images/WX20240307-122705.png" alt="WX20240307-122705.png"></p><h2 id="释放-TCP-连接"><a href="#释放-TCP-连接" class="headerlink" title="释放 TCP 连接"></a>释放 TCP 连接</h2><ol><li>FIN表示关闭连接</li></ol><p><img src="/../images/WX20240307-145108.png" alt="WX20240307-145108.png"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-02日记</title>
      <link href="/posts/217333d4/"/>
      <url>/posts/217333d4/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="518a1d5615d1d455493cead681a3426520306abb9ba76a6f0402961cb17a067c">026422d16125c0ef5486e4aca3c5daf506eac8b704d20a3e10d8dbe17b8641d586f098f2562ff378c8eaefc40cd08645fcb781c0c27175247887a8fa63710904c5fb41cc2077160fcb551c7176b562e7f0b1d3a29e848d56e354e3210cfad118b2029c1e8a692a35b614a0c9f658fa58fea90d31e7290f42931238ec4b8ecacbf28732c97ffd1f634c82720f065aa369dda264374aa10d648358b07e415b465fa735ba3ad5f3c0dcb85a1da85c1629e757cf15c3aa70d7f2ede01d21306263745580f3ddb8adfdad4df15f8cd5a62dab6841fd8c2c6404185b45868cc4ad394974c4615cbe06971040031512dcffd5eb82965e2bf4facbad941682a950324218787e58508d9784a4a20641a657c4a72b1b1c052f6faa7ac65455bbb8abb489108756e23767a49d9a28636faabe3af200ec73fc9e8b6e474b7fd8f4bfe3ace16c8b14b44cade6bfbe023e27658d9709d6fafd7f520e5fec55d6b06491eac610bee53cd9d77e8e0056f1d58e631593fdde154d7161e584656c9763a965aa207019</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解原始类型与对象类型</title>
      <link href="/posts/6b801e23/"/>
      <url>/posts/6b801e23/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原始类型的类型标注"><a href="#原始类型的类型标注" class="headerlink" title="原始类型的类型标注"></a>原始类型的类型标注</h1><p>除了最常见的number &#x2F; string &#x2F; boolean &#x2F; null &#x2F; undefined， ECMAScript 2015（ES6）、2020 (ES11)又分别引入了2个新的原始类型：symbol与bigint 。在TypeScript中它们都有对应的类型注解：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;linbudu&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">male</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">undef</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">nul</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="built_in">object</span> = &#123; name, age, male &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bigintVar1</span>: <span class="built_in">bigint</span> = <span class="number">9007199254740991n</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">bigintVar2</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="number">9007199254740991</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">symbolVar</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;unique&#x27;</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h1><p>在JavaScript中，null与undefined分别表示”这里有值，但是个空值”和”这里没有值”。而在TypeScript中，null与undefined类型都是有具体意义的类型。也就是说，它们作为类型时，表示的是一个有意义的具体类型值。这两者在没有开启 strictNullChecks 检查的情况下，会被视作其他类型的子类型，比如string类型会被认为包含了null与undefined类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">tmp1</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp2</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp3</span>: <span class="built_in">string</span> = <span class="literal">null</span>; <span class="comment">// 仅在关闭 strictNullChecks 时成立，下同</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tmp4</span>: <span class="built_in">string</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>用于表示一个独一无二的值。</p><h2 id="Symbol特点："><a href="#Symbol特点：" class="headerlink" title="Symbol特点："></a>Symbol特点：</h2><ol><li>Symbol的值是唯一的，用来解决命名冲突问题</li><li>Symbol值不能与其他数据进行运算</li><li>Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</li></ol><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦吖&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// Symbol(末晨曦吖)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">//symbol</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦吖&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Symbol中的方法"><a href="#Symbol中的方法" class="headerlink" title="Symbol中的方法"></a>Symbol中的方法</h2><h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h3><p>参数是symbol类型的描述信息，不同于Symbol()，这个而参数只能是字符串或者是undefined，若已经创建了则返回这个symbol，否则就进行创建并将这个新的symbol返回，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name === name1);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name === name1);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>请注意，我们在使用创建描述信息为”末晨曦”的变量的时候，使用的是for，而不是Symbol()，倘若使用Symbol()进行首次创建，for会再次创建一次，二者不会相等。<br>原因在于Symbol.for()会有一个登记机制，使用for只会对通过for创建的symbol进行检查，不会对Symbol()创建的进行检查。</p><h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h3><p>这个方法参数是一个通过Symbol.for()创建的symbol类型变量，返回这个symbol变量的描述信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name)); <span class="comment">// &quot;末晨曦&quot;</span></span><br><span class="line"><span class="keyword">let</span> name1 = <span class="title class_">Symbol</span>(<span class="string">&quot;末晨曦&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(name1)); <span class="comment">// undefined　不能查找Symbol()创建的变量</span></span><br></pre></td></tr></table></figure><h1 id="对象的类型标注"><a href="#对象的类型标注" class="headerlink" title="对象的类型标注"></a>对象的类型标注</h1><p>首先我们使用interface声明一个结构，然后使用这个结构来作为一个对象的类型标注即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDescription</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">male</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">IDescription</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;linbudu&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">599</span>,</span><br><span class="line">    <span class="attr">male</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="修饰接口属性"><a href="#修饰接口属性" class="headerlink" title="修饰接口属性"></a>修饰接口属性</h1><p>在接口结构中通过 ? 来标记一个属性为可选：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDescription</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">male</span>?: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">func</span>?: <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj2</span>: <span class="title class_">IDescription</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;linbudu&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">599</span>,</span><br><span class="line">    <span class="attr">male</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 无需实现 func 也是合法的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>readonly 它的作用是防止对象的属性被再次赋值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDescription</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj3</span>: <span class="title class_">IDescription</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;linbudu&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">599</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法分配到 &quot;name&quot; ，因为它是只读属性</span></span><br><span class="line">obj3.<span class="property">name</span> = <span class="string">&quot;林不渡&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/caihongmin/p/16668774.html">JS第七种数据类型Symbol详解 </a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> TS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API简介</title>
      <link href="/posts/51ea29d7/"/>
      <url>/posts/51ea29d7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="API是什么"><a href="#API是什么" class="headerlink" title="API是什么"></a>API是什么</h1><p>API(Application ProgrammingInterface)提供了对某个问题的抽象，以及客户与解决该问题的软件组件之间进行交互的方式。</p><h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><p>接口是开发者所编写的最重要的代码。因为比起相关的实现代码出现问题，修复接口出现的问题代价要大得多。</p><ol><li>修改API时，必须尽可能保证向后兼容。</li><li>出于向后兼容的需求，一定要具有变更控制流程。（如人工审核，代码自动化审核）</li><li>在编写API时，良好的文档和注释必不可少。</li><li>自动化测试同样也很重要。</li></ol><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API特征</title>
      <link href="/posts/33481a84/"/>
      <url>/posts/33481a84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h1><h2 id="可发现性"><a href="#可发现性" class="headerlink" title="可发现性"></a>可发现性</h2><p>可发现的API要求用户能够通过API明白如何使用它们，而不需要参阅任何解释或文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Button 类的方法 setOnClickListener(),表示设置点击监听器,语义清晰。</span><br><span class="line">TextView 类的方法 getText(),表示获取文字内容。</span><br><span class="line">ListView 类方法 getChildAt(<span class="type">int</span> index),参数index表示子项索引位置。</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="不易误用"><a href="#不易误用" class="headerlink" title="不易误用"></a>不易误用</h2><blockquote><p>使用枚举类型代替布尔类型，提高代码的可读性。</p></blockquote><p>使用枚举而不是布尔值或整数常量。枚举可以清晰表明参数的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Visibility</span> &#123;</span><br><span class="line">    VISIBLE, INVISIBLE, GONE  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVisibility</span><span class="params">(Visibility visibility)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrientationHelper</span> &#123;</span><br><span class="line">    HORIZONTAL, VERTICAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mLayoutManager.setOrientation(OrientationHelper.VERTICAL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>避免编写拥有多个相同类型参数的函数.</p></blockquote><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createBook</span><span class="params">(String publisher, String illustrator, String author)</span></span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void createBook(Book book)</span><br><span class="line"></span><br><span class="line">Book book = new BookBuilder().withPublisher(...)</span><br><span class="line">                             .withIllustrator(...)</span><br><span class="line">                             .withAuthor(...)</span><br><span class="line">                             .build();</span><br></pre></td></tr></table></figure><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>关于API设计的一致性,主要可以从以下几个方面来理解:</p><p>1.命名一致性 - API中的命名应该保持一致性,如方法名、参数名、返回值等命名要有统一的规范。常见的做法是使用驼峰式命名法等。<br>2.参数格式一致性 - 对于同类方法,其参数格式应保持一致,如查询类方法的分页参数pageSize、pageNum应该统一。<br>3.返回格式一致性 - 对于同类型的返回数据,格式应该保持一致,如都返回JSON格式的数据。<br>4.错误处理一致性 - 对于错误的定义、错误码的命名等都应该保持一致性。<br>5.安全机制一致性 - 如果有认证、授权等安全机制,各个API应该遵循统一的安全规范。<br>6.版本控制一致性 - API的版本控制应该有一致的规范,如使用版本号区分新老版本API等。<br>7.文档规范一致性 - API的文档规范应该保持一致性,如都遵循统一的文档模板等。</p><h2 id="正交"><a href="#正交" class="headerlink" title="正交"></a>正交</h2><blockquote><p>正交的API意味着函数没有副作用。</p></blockquote><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheapMotelShower</span> &#123;</span><br><span class="line">    <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mTemperature;</span><br><span class="line">    <span class="comment">// 水压</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mPower;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTemperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetPower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetPower</span><span class="params">(<span class="type">float</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">100</span>)</span><br><span class="line">            p = <span class="number">100</span>;</span><br><span class="line">        mPower = p;</span><br><span class="line">        mTemperature = <span class="number">42.0f</span> + (<span class="type">float</span>) Math.sin(p / <span class="number">38.0f</span>) * <span class="number">45.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SetPower()方法会对GetTemperature()方法的结果产生副作用。在更加复杂的系统中，这种相互依赖性可能会被程序员遗忘，或者被忽视，进而对代码区域的简单地改动就可能对系统其他部分的行为产生的影响。</p><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdealShower</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mTemperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> mPower;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTemperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">GetPower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetTemperature</span><span class="params">(<span class="type">float</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">42</span>)</span><br><span class="line">            t = <span class="number">42</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">85</span>)</span><br><span class="line">            t = <span class="number">85</span>;</span><br><span class="line">        mTemperature = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetPower</span><span class="params">(<span class="type">float</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span>)</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">100</span>)</span><br><span class="line">            p = <span class="number">100</span>;</span><br><span class="line">        mPower = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计正交API时需要铭记如下两个重要因素</p><ol><li>减少冗余。确保只用一种方式表示相同的信息。每条信息应该只有唯一的权威来源。</li><li>增加独立性。确保暴露的概念没有重叠。任何重叠的概念都应该分解到它们的基础组件中。</li></ol><h1 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h1><blockquote><p>优秀的API表现为松耦合和高内聚。</p></blockquote><ol><li>耦合 给定A和B两个组件，当A改变时需要改变B中多少代码。</li><li>内聚  高内聚是指一个软件模块由相关性很强的代码组成，只负责一项任务。也被称为单一责任原则。</li></ol><h1 id="稳定性、文档详细"><a href="#稳定性、文档详细" class="headerlink" title="稳定性、文档详细"></a>稳定性、文档详细</h1><ol><li>优秀的API设计应该是稳定的且具有前瞻性.<br>稳定并不意味着API不会改变，而是应该将接口版本化，并且在版本升级时保证向后兼容<br>前瞻性表示API应该设计为可扩展的，以便它能优雅的升级而不是被修改得一塌糊涂</li><li>优秀的API设计也应该有很好的文档支持，以便用户获取API的功能、行为、最佳实践以及错误条件的明确信息.</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li>C++ API设计</li><li>如何设计一个优秀的API</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络优化</title>
      <link href="/posts/1684077/"/>
      <url>/posts/1684077/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>包体积优化</title>
      <link href="/posts/4767ff81/"/>
      <url>/posts/4767ff81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="包体积优化"><a href="#包体积优化" class="headerlink" title="包体积优化"></a>包体积优化</h1><ol><li>针对 dex 的优化，例如 Proguard、dex 的 DebugItem 删除、字节码优化等；</li><li>针对 resource 的优化，例如 AndResGuard、webp 优化等；</li><li>针对 assets 的优化，例如压缩、动态下发等；</li><li>针对 so 的优化，同 assets，另外还有移除调试符号等。</li></ol><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://tech.meituan.com/2022/06/02/meituans-technical-exploration-and-practice-of-android-so-volume-optimization.html">Android对so体积优化的探索与实践</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程软件</title>
      <link href="/posts/ff82d35e/"/>
      <url>/posts/ff82d35e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Intellij-IDEA-激活"><a href="#Intellij-IDEA-激活" class="headerlink" title="Intellij IDEA 激活"></a>Intellij IDEA 激活</h1><ol><li>Mac</li></ol><p><img src="/../images/20240108152553474203.webp" alt="20240108152553474203.webp"></p><p><img src="/../images/20240108152843416282.webp" alt="20240108152843416282.webp"></p><ol start="2"><li>Win</li></ol><p><img src="/../images/20240108143333072536.webp" alt="20240108143333072536.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SDK</title>
      <link href="/posts/e4a05be2/"/>
      <url>/posts/e4a05be2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编程常用缩写"><a href="#编程常用缩写" class="headerlink" title="编程常用缩写"></a>编程常用缩写</h1><p><a href="https://blog.csdn.net/elegant__/article/details/9748835">https://blog.csdn.net/elegant__&#x2F;article&#x2F;details&#x2F;9748835</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类和接口</title>
      <link href="/posts/15ea71ed/"/>
      <url>/posts/15ea71ed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h1><p><strong>尽可能使每个类或者成员不被外界访问。</strong></p><p>对于成员（字段、方法、嵌套类和嵌套接口）有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：</p><ul><li><p><strong>私有的（private）</strong> ———— 只有在声明该成员的顶层类内部才可以访问这个成员。</p></li><li><p><strong>包级私有的（package-private）</strong> ———— 声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为“缺省（default）”访问级别，如果你没有声明访问修饰符，就是这个访问级别（除了接口的成员，接口成员默认是公有的）。</p></li><li><p><strong>受保护的（protedted）</strong> ———— 声明该成员的类的子类可以访问这个成员（但有一些限制[JLS, 6.6.2]），并且，声明该成员的包内部的任何类也可以访问这个成员。</p></li><li><p><strong>公有的（public）</strong> ———— 在任何地方都可以访问该成员。</p></li></ul><span id="more"></span><p><strong>实例字段决不能是公有的</strong> </p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> publicField;  <span class="comment">// 错误的方式，实例字段应该是私有的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> privateField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrivateField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> privateField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrivateField</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        privateField = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类具有公有的静态 final 数组字段，或者返回这种字段的访问方法，这是错误的。</strong></p><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Potential security hole!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h1><p>为了使类成为不可变类，要遵循一下五条原则：</p><ol><li><strong>不要提供任何修改对象状态的方法（也称为 mutators） 。</strong></li><li><strong>保证类不会被扩展。</strong> 可以将该类声明为final。</li><li><strong>使所有字段都是 final 的。</strong></li><li><strong>使所有的字段都是私有的。</strong></li><li><strong>确保对于任何可变组件的互斥访问。</strong></li></ol><p><strong>不可变对象本质上是线程安全的，它们不要求同步。</strong></p><p><strong>如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。</strong></p><h1 id="组合优先于继承"><a href="#组合优先于继承" class="headerlink" title="组合优先于继承"></a>组合优先于继承</h1><p>继承打破了封装性[Snyder86]。换句话说，子类依赖于其超类中特定功的功能实现。超类的实现有可能会随着版本的不同而有所变化，如果真的发生了变化，子类可能会遭受到破坏，即使它的代码完全没有改变。因而，子类必须跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。</p><h1 id="接口优先于抽象类"><a href="#接口优先于抽象类" class="headerlink" title="接口优先于抽象类"></a>接口优先于抽象类</h1><h1 id="接口只用于定义类型"><a href="#接口只用于定义类型" class="headerlink" title="接口只用于定义类型"></a>接口只用于定义类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constant interface antipattern - do not use!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhysicalConstants</span> &#123;</span><br><span class="line">    <span class="comment">// Avogadro&#x27;s number (1/mol)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">AVOGADROS_NUMBER</span> <span class="operator">=</span> <span class="number">6.022_140_857e23</span>;</span><br><span class="line">    <span class="comment">// Boltzmann constant (J/K)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">BOLTZMANN_CONSTANT</span> <span class="operator">=</span> <span class="number">1.380_648_52e-23</span>;</span><br><span class="line">    <span class="comment">// Mass of the electron (kg)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ELECTRON_MASS</span> <span class="operator">=</span> <span class="number">9.109_383_56e-31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量接口模式是对接口的不良使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对于所有对象都通用的方法</title>
      <link href="/posts/8779c14a/"/>
      <url>/posts/8779c14a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重写-equals-时请遵守通用约定"><a href="#重写-equals-时请遵守通用约定" class="headerlink" title="重写 equals 时请遵守通用约定"></a>重写 equals 时请遵守通用约定</h1><p>重写 equals 方法看起来似乎很简单，但是有许多重写方式会出现错误，而且后果非常严重。最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只能与它自身相等。如果满足了以下任何一个条件，那就是正确的做法：</p><span id="more"></span><ol><li><strong>类的每个实例都是唯一的。</strong> 例如 Thread。Object 提供的 equals 实现对这些类具有完全满足的行为。</li><li><strong>不关心类是否提供了“逻辑相等（logical equality）”的测试功能。</strong> 例如，java.util.regex.Pattern 。</li><li><strong>超类已经重写了 equals，从超类继承过来的行为对于子类也是合适的。</strong> 例如，大多数的 Set 实现都从 AbstractSet 继承 equals 实现，List 实现从 AbstractList 继承 equals 实现，Map 实现从 AbstractMap 继承 equals 实现。</li><li><strong>类是私有的或者是包级私有的，可以确定它的 equals 方法永远不会被调用。</strong></li></ol><p>那么什么时候重写 equals 方法才是合适的呢？当一个类具有逻辑相等的概念时（不同于对象本身相同的概念），而超类还没有重写 equals。 这通常是“值类（value class）”的情况。值类指的是只表示值的类，例如 Integer 或 String。程序猿在利用 equals 方法来比较对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否引用了相同的对象。</p><p><code>to do</code></p><h1 id="当重写-equals-方法时总要重写-hashCode-方法"><a href="#当重写-equals-方法时总要重写-hashCode-方法" class="headerlink" title="当重写 equals 方法时总要重写 hashCode 方法"></a>当重写 equals 方法时总要重写 hashCode 方法</h1><p>相等的对象必须具有相等的散列码（hash code）。</p><h1 id="始终重写-toString-方法"><a href="#始终重写-toString-方法" class="headerlink" title="始终重写 toString 方法"></a>始终重写 toString 方法</h1><p>提供一个好的 toString 实现会使你的类使用起来更加愉快，并使使用该类的系统更容易调试。</p><h1 id="谨慎地重写-clone-方法"><a href="#谨慎地重写-clone-方法" class="headerlink" title="谨慎地重写 clone 方法"></a>谨慎地重写 clone 方法</h1><p><code>to do</code></p><h1 id="考虑实现-Comparable-接口"><a href="#考虑实现-Comparable-接口" class="headerlink" title="考虑实现 Comparable 接口"></a>考虑实现 Comparable 接口</h1>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建和销毁对象</title>
      <link href="/posts/b4ee29f3/"/>
      <url>/posts/b4ee29f3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="考虑静态工厂方法而不是构造函数"><a href="#考虑静态工厂方法而不是构造函数" class="headerlink" title="考虑静态工厂方法而不是构造函数"></a>考虑静态工厂方法而不是构造函数</h1><p><strong>1. 静态工厂方法的一个优点是，它们是有名称的，而构造函数的名称都是一样的。</strong></p><p>如果构造函数的参数本身不能描述返回的对象，那么使用一个精心命名的静态工厂更容易使用，并且生成的客户端代码更容易阅读。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">probablePrime</span><span class="params">(<span class="type">int</span> bitLength, Random rnd)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bitLength &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;bitLength &lt; 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (bitLength &lt; SMALL_PRIME_THRESHOLD ?</span><br><span class="line">            smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) :</span><br><span class="line">            largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd));</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在一个类需要使用多个签名、多个构造函数的情况下，用静态工厂方法代替构造函数，并仔细选择方法的名称就可以突出构造函数之间的差异了。</p><p><strong>2. 与构造函数不同，它们不需要在每次被调用时创建一个新对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">TRUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FALSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 静态工厂方法的第三个优点是，与构造函数不同，它们返回的对象可以是返回类型的任何子类的实例对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Person &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 这里可以改为 return new Player() / Cooker()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class Player <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Class Cooker <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 静态工厂方法的第四个优点是，静态工厂方法所返回的对象的类可以随着每次调用而变化，这取决于静态工厂方法的参数值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="comment">// 抽象类的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="comment">// Apple类的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="comment">// Orange类的具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">createFruit</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;apple&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;orange&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Orange</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid fruit type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 静态工厂方法的第五个优点是，返回的对象所属的类，在编写包含该静态工厂方法的类时可以不必存在。</strong></p><p>以下是一个简单的示例代码，演示了如何使用服务提供者框架来实现和使用服务：</p><p>首先，定义一个服务接口<code>Shape</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，实现两个不同的形状类<code>Circle</code>和<code>Rectangle</code>，它们都实现了<code>Shape</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a rectangle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，创建一个服务提供者接口<code>ShapeProvider</code>，它定义了一个方法<code>getShape()</code>来获取<code>Shape</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ShapeProvider</span> &#123;</span><br><span class="line">    Shape <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，实现两个不同的服务提供者类<code>CircleProvider</code>和<code>RectangleProvider</code>，它们实现了<code>ShapeProvider</code>接口，并分别返回<code>Circle</code>和<code>Rectangle</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleProvider</span> <span class="keyword">implements</span> <span class="title class_">ShapeProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleProvider</span> <span class="keyword">implements</span> <span class="title class_">ShapeProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，创建一个客户端类<code>ShapeClient</code>，它使用服务提供者框架来获取并使用<code>Shape</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ShapeProvider shapeProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShapeClient</span><span class="params">(ShapeProvider shapeProvider)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shapeProvider = shapeProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> shapeProvider.getShape();</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，可以在主函数中使用服务提供者框架来创建<code>ShapeClient</code>实例，并调用<code>drawShape()</code>方法来绘制形状：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShapeProvider</span> <span class="variable">circleProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleProvider</span>();</span><br><span class="line">        <span class="type">ShapeClient</span> <span class="variable">circleClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeClient</span>(circleProvider);</span><br><span class="line">        circleClient.drawShape();</span><br><span class="line">        </span><br><span class="line">        <span class="type">ShapeProvider</span> <span class="variable">rectangleProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RectangleProvider</span>();</span><br><span class="line">        <span class="type">ShapeClient</span> <span class="variable">rectangleClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeClient</span>(rectangleProvider);</span><br><span class="line">        rectangleClient.drawShape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，通过使用服务提供者框架，<code>ShapeClient</code>类不需要直接引用具体的形状类&#96;</p><p><strong>6. 静态工厂方法的主要限制在于，类如果不含公有的或者受保护的构造器，就不能被子类化。</strong></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器，不允许直接使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法，用于创建具有指定名称的 Animal 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">createAnimal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法创建公有或受保护的构造器，因为父类 Animal 的构造器是私有的</span></span><br><span class="line">    <span class="comment">// public Dog(String name, String breed) &#123;</span></span><br><span class="line">    <span class="comment">//     super(name);</span></span><br><span class="line">    <span class="comment">//     this.breed = breed;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法创建受保护的构造器，因为父类 Animal 的构造器是私有的</span></span><br><span class="line">    <span class="comment">// protected Dog(String name, String breed) &#123;</span></span><br><span class="line">    <span class="comment">//     super(name);</span></span><br><span class="line">    <span class="comment">//     this.breed = breed;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Animal</code> 类有一个私有的构造器，不允许直接使用。我们使用了一个静态工厂方法 <code>createAnimal</code> 来创建 <code>Animal</code> 实例。</p><p><code>Dog</code> 类继承自 <code>Animal</code> 类，但由于 <code>Animal</code> 类的构造器是私有的，<code>Dog</code> 类无法创建公有或受保护的构造器。因此，<code>Dog</code> 类无法被子类化。</p><p>如果我们想让 <code>Animal</code> 类可以被子类化，就需要提供一个公有的或者受保护的构造器。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 受保护的构造器，允许子类访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法，用于创建具有指定名称的 Animal 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">createAnimal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的构造器，允许直接使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>Dog</code> 类可以被子类化，因为我们提供了一个公有的构造器。</p><p><strong>7. 静态工厂方法的第二个缺点是程序猿很难找到它们。</strong></p><p>通过遵守常见的命名约定来减少此问题。</p><ol><li>from：一种类型转换方法，它接受单个参数并返回此类型的相应实例，例如：<code>Date d = Date.from(instant);</code></li><li>of：一种聚合方法，它接受多个参数并返回包含它们的此类型的实例，例如：<code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</code></li><li>valueOf：一个更详细的替代方案，例如：<code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></li><li>instance or getInstance：返回由其参数（如果有）描述的实例，但不能说它具有相同的值，例如：<code>StackWalker luke = StackWalker.getInstance(options);</code></li><li>create or newInstance：与 instance 或 getInstance 类似，不同之处在于该方法保证每个调用都返回一个新实例，例如：<code>Object newArray = Array.newInstance(classObject, arrayLen);</code></li><li>getType：与 getInstance 类似，是在工厂方法位于不同的类中时使用它。Type 指的是工厂方法返回的对象类型，例如：<code>FileStore fs = Files.getFileStore(path);</code></li><li>newType：与 newInstance 类似，是在工厂方法位于不同的类中时使用它。Type 指的是工厂方法返回的对象类型，例如：<code>BufferedReader br = Files.newBufferedReader(path);</code></li><li>type：获取 Type 和 new Type 一个简明替代的方法，比如：<code>List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</code></li></ol><h1 id="当面临多个参数的构造器时考虑使用构建器"><a href="#当面临多个参数的构造器时考虑使用构建器" class="headerlink" title="当面临多个参数的构造器时考虑使用构建器"></a>当面临多个参数的构造器时考虑使用构建器</h1><p>静态工厂和构造器有个共同的局限性：他们都不能很好地扩展到大量的可选参数。</p><p>下面有个示例，为了简单起见，它显示四个可选域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Telescoping constructor pattern - does not scale well!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize; <span class="comment">// (mL) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings; <span class="comment">// (per container) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories; <span class="comment">// (per serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat; <span class="comment">// (g/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium; <span class="comment">// (mg/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate; <span class="comment">// (g/serving) optional</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbohydrate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.fat = fat;</span><br><span class="line">        <span class="built_in">this</span>.sodium = sodium;</span><br><span class="line">        <span class="built_in">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>重叠构造器模式是可行的，但是当有很多参数的时候就很难编写客户端代码，也很难去阅读它们。</li><li>长串类型相同的参数会导致一些微妙的错误，如果客户端不小心颠倒了其中两个参数的顺序，编译器也不会报错，但是程序在运行的时候就会出现错误的行为。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="comment">// Parameters initialized to default values (if any)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servingSize</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servings</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServingSize</span><span class="params">(<span class="type">int</span> val)</span> &#123; servingSize = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServings</span><span class="params">(<span class="type">int</span> val)</span> &#123; servings = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCalories</span><span class="params">(<span class="type">int</span> val)</span> &#123; calories = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFat</span><span class="params">(<span class="type">int</span> val)</span> &#123; fat = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSodium</span><span class="params">(<span class="type">int</span> val)</span> &#123; sodium = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>();</span><br><span class="line">cocaCola.setServingSize(<span class="number">240</span>);</span><br><span class="line">cocaCola.setServings(<span class="number">8</span>);</span><br><span class="line">cocaCola.setCalories(<span class="number">100</span>);</span><br><span class="line">cocaCola.setSodium(<span class="number">35</span>);</span><br><span class="line">cocaCola.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure><ol><li>JavaBean模式弥补了重叠构造器模式的不足。创建实例很容易，产生的代码读起来也很容易。</li><li>因为构造过程被分到了几个调用中，在构造的过程中 JavaBean 可能处于不一致的状态。无法保证线程安全。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sodium</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">carbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>.Builder(<span class="number">240</span>, <span class="number">8</span>).calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><ol><li>Builder模式结合了重叠构造器的安全性和JavaBean模式的可读性。</li><li>Builder 模式也有缺点。要创建对象，必须先创建其构建器。虽然在实践中创建此构建器的成本可能不太明显，但在性能关键的情况下可能会出现问题。</li></ol><p>建造者模式非常适合用于类层次结构。可以使用并行的建造者层次结构，<br>每个建造者都嵌套在相应的类中。抽象类拥有抽象建造者；具体类拥有具体建造者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder pattern for class hierarchies</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Topping</span> &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Builder</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">addTopping</span><span class="params">(Topping topping)</span> &#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">abstract</span> Pizza <span class="title function_">build</span><span class="params">()</span>;</span><br><span class="line">        <span class="comment">// Subclasses must override this method to return &quot;this&quot;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">self</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// See Item 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NyPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span> &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(Size size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> NyPizza <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NyPizza</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calzone</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span>.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">sauceInside</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Default</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sauceInside</span><span class="params">()</span> &#123;</span><br><span class="line">            sauceInside = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> Calzone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">protected</span> Builder <span class="title function_">self</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Calzone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">NyPizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NyPizza</span>.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line"><span class="type">Calzone</span> <span class="variable">calzone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calzone</span>.Builder().addTopping(HAM).sauceInside().build();</span><br></pre></td></tr></table></figure><h1 id="用私有构造器或者枚举类型强化-Singleton-属性"><a href="#用私有构造器或者枚举类型强化-Singleton-属性" class="headerlink" title="用私有构造器或者枚举类型强化 Singleton 属性"></a>用私有构造器或者枚举类型强化 Singleton 属性</h1><p>Singleton 指仅仅被实例化一次的类。</p><p>实现单例的方法有两种。 两者都基于保持构造函数私有并导出公共静态成员以提供对唯一实例的访问。</p><ol><li>第一种</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>第二种<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>readResolve</code>方法是Java中的一个特殊方法，用于在反序列化过程中控制对象的创建。当一个被序列化的对象被反序列化时，会调用该对象的<br><code>readResolve</code>方法来获取要返回的实例。通过在单例类中实现<code>readResolve</code>方法，可以确保反序列化后返回同一个单例对象，从而保持单例属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">    <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三种<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtilityClass</span> &#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">UtilityClass</span><span class="params">(( &#123;</span></span><br><span class="line"><span class="params">        throw new AssertionError()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="避免创建不需要的对象"><a href="#避免创建不需要的对象" class="headerlink" title="避免创建不需要的对象"></a>避免创建不需要的对象</h1><p><strong>错误示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;bikini&quot;</span>); <span class="comment">// DON&#x27;T DO THIS!</span></span><br></pre></td></tr></table></figure><p><strong>正确示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;bikini&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>错误示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s.matches(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">        + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然String.matches是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能关键的情况下重复使用。问题是它在内部为正则表达式创建了一个 Pattern 实例，<br>并且只使用它一次，之后它就可能会被垃圾回收机制回收。创建 Pattern 实例的代价很大，因为它需要将正则表达式编译为有限状态机</p><p><strong>正确示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RomanNumerals</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ROMAN</span> <span class="operator">=</span> Pattern.compile(</span><br><span class="line">        <span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">        + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 sum 被声明成 Long 而不是 long，意味着程序构造了大约 2^31 个多余的 Long 实例（大约每次往 Long sum 中增加 long 时构造一个实例）。</p><h1 id="清除过期对象的引用"><a href="#清除过期对象的引用" class="headerlink" title="清除过期对象的引用"></a>清除过期对象的引用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can you spot the &quot;memory leak&quot;?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">     * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，每当调用 pop() 方法弹出栈中的一个对象时，实际上是将 size 减小了，<br>但数组 elements 中的对应位置并没有置为 null。因此，被弹出的对象仍然占用着数组的空间，并且栈内部仍然保持着对这些对象的引用。</p><p>正确写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// 将弹出的对象引用置为 null</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="try-with-resources-优先于-try-finally"><a href="#try-with-resources-优先于-try-finally" class="headerlink" title="try-with-resources 优先于 try-finally"></a>try-with-resources 优先于 try-finally</h1><p>Java 库包含许多必须通过调用 close 方法手动关闭的资源。示例包括 InputStream，OutputStream 和 java.sql.Connection。</p><p>在之前的做法中(Historically)，try-finally 语句是保证资源正确关闭的最佳方式，<br>即使出现异常或在 return 的时候(even in the face of an exception or return)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来并不差，但是当你添加第二个资源的时候，它会变得很糟糕：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">            out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使是使用 try-finally 语句关闭资源的正确代码，如前两个代码示例所示，也有一个微妙的缺陷。try 块和 finally 块中的代码都能够抛出异常。例如，在 firstLineOfFile 方法中，对 readLine 的调用可能由于底层物理设备中的故障而引发异常，并且由于相同的原因，对 close 的调用可能会失败。在这种情况下，第二个异常完全覆盖了第一个异常。异常堆栈跟踪中没有第一个异常的记录，这可能会使实际系统中的调试变得非常复杂 - 通常第一个异常才是你要查看并诊断问题的关键所在(usually it’s the first exception that you want to see in order to diagnose the problem)。虽然有可能编写代码来抑制第二个异常而支持第一个异常，但几乎没有人这样做，因为它太冗余了。</p><p>当 Java 7 引入了 try-with-resources 语句[JLS，14.20.3]时，所有这些问题都得到了一并解决。要使用此构造，资源必须实现 AutoCloseable 接口。</p><p>try-with-resources 示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// BufferedReader 必须实现 AutoCloseable 接口</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在处理必须关闭的资源时，相比于 try-finally，始终优先使用 try-with-resources。生成的代码更短更清晰，它生成的异常更有用。try-with-resources 语句可以在使用必须关闭的资源的同同时轻松编写正确的代码，使用 try-finally 几乎是不可能的。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://gitee.com/lixudong1997/effective-java-third-edition">https://gitee.com/lixudong1997/effective-java-third-edition</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> EFFECTIVE JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插件</title>
      <link href="/posts/1562b2a5/"/>
      <url>/posts/1562b2a5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm i <span class="meta">@waline</span>/client</span><br><span class="line">npm install hexo-abbrlink --save</span><br><span class="line">npm install --save hexo-blog-encrypt</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-douban --save</span><br><span class="line">npm install hexo-hide-posts</span><br><span class="line">npm install hexo-lazyload-image --save</span><br><span class="line">npm install hexo-word-counter</span><br><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure><h1 id="查看已经安装的插件"><a href="#查看已经安装的插件" class="headerlink" title="查看已经安装的插件"></a>查看已经安装的插件</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list --depth <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github超时解决</title>
      <link href="/posts/89793def/"/>
      <url>/posts/89793def/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IP-映射"><a href="#IP-映射" class="headerlink" title="IP 映射"></a>IP 映射</h1><ol><li><p>找到GithubIP<br><a href="https://sites.ipaddress.com/github.com/">https://sites.ipaddress.com/github.com/</a><br>通过这个网站找到IP</p></li><li><p>打开hosts文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /<span class="keyword">private</span>/etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>将IP地址替换为第一步找到的IP，复制粘贴到Hosts文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP地址  github.com</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用开源软件"><a href="#使用开源软件" class="headerlink" title="使用开源软件"></a>使用开源软件</h1><p><a href="https://github.com/docmirror/dev-sidecar">dev-sidecar</a></p><p>然后使用按一下<code>ESC</code>，输入<code>:wq</code>保存并退出。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clean code</title>
      <link href="/posts/73a9e291/"/>
      <url>/posts/73a9e291/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h1><h2 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">realDaysPerIdealDay</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">const <span class="type">int</span> <span class="variable">WORK_DAYS_PER_WEEK</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="命令查询分离"><a href="#命令查询分离" class="headerlink" title="命令查询分离"></a>命令查询分离</h2><p>函数要么做某事，要么回答某事，但不能两者兼而有之。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String attribute, String value)</span>;</span><br></pre></td></tr></table></figure><p>该函数设置某个指定属性，如果成功就返回 ue，如果不存在那个属性则返回 false。这样就导致了以下语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>))...</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (attributeExists(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">    setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;unclebob&quot;</span>);</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>最理想的参数数量是零(零参数函数)，其次是一《单参数函数)，再次是二 (双参数函数)，应尽量避免三 (三参数函数)。有足够特殊的理由才能用三个以上参数《多参数函数)-所以无论如何也不要这么做。</p><h2 id="使用异常替代返回错误码"><a href="#使用异常替代返回错误码" class="headerlink" title="使用异常替代返回错误码"></a>使用异常替代返回错误码</h2><p>从指令式函数返回错误码轻微违反了指令与询问分隔的规则。它鼓励了在 if语句判断中把指令当作表达式使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage(page) == E_OK)</span><br></pre></td></tr></table></figure><p>这不会引起动词&#x2F;形容词混淆，但却导致更深层次的嵌套结构。当返回错误码时，就是在要求调用者立刻处理错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (deletePage(page) == E_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (registry.deleteReference(page.name) == E_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configKeys.deleteKey(page.name.makeKey()) == E_OK)&#123;</span><br><span class="line">            logger.log(<span class="string">&quot;page deleted&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.log(<span class="string">&quot;configKey not deleted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.log(<span class="string">&quot;deleteReference from registry failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    logger.log(<span class="string">&quot;delete failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> E_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要使用标记位做为函数参数"><a href="#不要使用标记位做为函数参数" class="headerlink" title="不要使用标记位做为函数参数"></a>不要使用标记位做为函数参数</h2><p>标记位是告诉你的用户这个函数做了不只一件事情。 函数应该只做一件事情。 如果你的函数因为一个布尔值 出现不同的代码路径， 请拆分它们。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createFile</span><span class="params">(String name,<span class="type">boolean</span> temp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./temp&quot;</span>+name);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">File</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createFile</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createTempFile</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./temp&quot;</span>+name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式编程优于指令式编程"><a href="#函数式编程优于指令式编程" class="headerlink" title="函数式编程优于指令式编程"></a>函数式编程优于指令式编程</h2><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; programmerOutput=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">programmerOutput.add(<span class="number">500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">150</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1000</span>);</span><br><span class="line"><span class="type">int</span> totalOutput=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;programmerOutput.size();i++)&#123;</span><br><span class="line">    totalOutput+=programmerOutput.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; programmerOutput = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">programmerOutput.add(<span class="number">500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1500</span>);</span><br><span class="line">programmerOutput.add(<span class="number">150</span>);</span><br><span class="line">programmerOutput.add(<span class="number">1000</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">totalOutput</span> <span class="operator">=</span> programmerOutput.stream()</span><br><span class="line">        .filter(programmer -&gt; programmer &gt; <span class="number">500</span>)</span><br><span class="line">        .mapToInt(programmer -&gt; programmer)</span><br><span class="line">        .sum();</span><br></pre></td></tr></table></figure><h2 id="避免负面条件"><a href="#避免负面条件" class="headerlink" title="避免负面条件"></a>避免负面条件</h2><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">isDOMNodeNotPresent</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isDOMNodeNotPresent(node)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">isDOMNodePresent</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDOMNodePresent(node)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="使用-getters-和-setters"><a href="#使用-getters-和-setters" class="headerlink" title="使用 getters 和 setters"></a>使用 getters 和 setters</h2><p><strong>错误示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class BankAccount &#123;</span><br><span class="line">    public int balance=1000;</span><br><span class="line">&#125;</span><br><span class="line">BankAccount bankAccount=new BankAccount();</span><br><span class="line">bankAccount.balance-=100;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> blance=<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBlance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> blance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBlance</span><span class="params">(<span class="type">int</span> blance)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(verifyIfAmountCanBeSetted(blance))&#123;</span><br><span class="line">                <span class="built_in">this</span>.blance = blance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">verifyIfAmountCanBeSetted</span><span class="params">(<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BankAccount bankAccount=<span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line">    bankAccount.setBlance(<span class="number">2000</span>);</span><br><span class="line">    <span class="type">int</span> balance=bankAccount.getBlance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="不要返回Null值"><a href="#不要返回Null值" class="headerlink" title="不要返回Null值"></a>不要返回Null值</h2><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ItemRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> peristentStore.getItemRegistry();</span><br><span class="line">        <span class="keyword">if</span> (registry != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">existing</span> <span class="operator">=</span> registry.getItem(item.getID());</span><br><span class="line">            <span class="keyword">if</span> (existing.getBillingPeriod().hasRetailOwner()) &#123;</span><br><span class="line">                existing.register(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回 null值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 nul1 值，应用程序就会失控。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="keyword">if</span> (employees != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">        totalPay += e.getPay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = getEmployees();</span><br><span class="line"><span class="keyword">for</span>(Employee e : employees) &#123;</span><br><span class="line">    totalPay += e.getPay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( .. there are no employees .. )</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要传递Null值"><a href="#不要传递Null值" class="headerlink" title="不要传递Null值"></a>不要传递Null值</h2><p>在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。除非 API要求你向它传递 null 值，否则就要尽可能避免传递 null 值。</p><p><strong>错误示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">xProjection</span><span class="params">(Point p1, Point p2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (p2.x – p1.x) * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">xProjection</span><span class="params">(<span class="meta">@NotNull</span> Point p1, <span class="meta">@NotNull</span> Point p2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p2.x – p1.x) * <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恰当的做法就是禁止传入 null 值。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://github.com/shizhongyu/clean-code-java">https://github.com/shizhongyu/clean-code-java</a></li><li><a href="https://book.douban.com/subject/4199741/">代码整洁之道</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>var 和 let</title>
      <link href="/posts/bf2b1bc1/"/>
      <url>/posts/bf2b1bc1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a><strong>作用域：</strong></h1><ul><li><code>let</code> 具有块级作用域，只在声明的块或语句内部可见。</li><li><code>var</code> 具有函数级作用域，可在整个函数内部访问。</li></ul><p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的作用域区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">// 块级作用域内的变量</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">20</span>; <span class="comment">// 函数级作用域内的变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出 20</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 错误：x 未定义</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>x</code> 是使用 <code>let</code> 声明的变量，它只在 <code>if</code> 语句块内部可见。而 <code>y</code> 是使用 <code>var</code> 声明的变量，它在整个函数内部都可见。</p><span id="more"></span><h1 id="变量提升："><a href="#变量提升：" class="headerlink" title="变量提升："></a><strong>变量提升：</strong></h1><ul><li>使用 <code>let</code> 声明的变量不存在变量提升，必须在声明之后才能访问。</li><li>使用 <code>var</code> 声明的变量会被提升到其作用域的顶部，可以在声明之前访问。</li></ul><p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的变量提升区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出 undefined</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 错误：y 未定义</span></span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用 <code>var</code> 声明的变量 <code>x</code> 在声明之前可以访问，但它的值为 <code>undefined</code>。而使用 <code>let</code> 声明的变量 <code>y</code> 在声明之前是不可访问的。</p><h1 id="重复声明："><a href="#重复声明：" class="headerlink" title="重复声明："></a><strong>重复声明：</strong></h1><ul><li>使用 <code>let</code> 声明的变量不允许在同一作用域内重复声明。</li><li>使用 <code>var</code> 声明的变量允许在同一作用域内重复声明，并且后面的声明会覆盖前面的声明。</li></ul><p>以下是一个示例，展示了 <code>let</code> 和 <code>var</code> 的重复声明区别：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">20</span>; <span class="comment">// 错误：无法重新声明块级作用域的</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>; <span class="comment">// 重复声明，覆盖前面的声明</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包与 var：</strong><br>使用 <code>var</code> 声明的变量在闭包中具有共享的作用域。这意味着闭包内部的函数可以访问和修改外部函数中声明的变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>inner</code> 函数可以访问外部函数 <code>example</code> 中声明的变量 <code>x</code>。</p><p><strong>闭包与 let：</strong><br>使用 <code>let</code> 声明的变量在闭包中具有独立的作用域。每次迭代或调用闭包时，都会创建一个新的变量实例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>setTimeout</code> 函数中的回调函数形成了闭包。使用 <code>let</code> 声明的变量 <code>i</code> 在每次迭代时都会创建一个新的实例，因此每个闭包都能够访问到正确的值。</p><p>相比之下，如果我们使用 <code>var</code> 声明变量 <code>i</code>，则所有的闭包都会共享同一个 <code>i</code>，导致输出结果为 <code>5</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5, 5, 5, 5, 5</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p>在这个示例中，由于 <code>var</code> 声明的 <code>i</code> 在全局作用域中共享，所有的闭包都使用了相同的 <code>i</code> 值。</p><p>通过使用 <code>let</code> 声明变量，我们确保了每个闭包都可以访问到正确的值，而不会受到循环的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> TS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JIT和AOT</title>
      <link href="/posts/6c825f47/"/>
      <url>/posts/6c825f47/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AOT，JIT是什么"><a href="#AOT，JIT是什么" class="headerlink" title="AOT，JIT是什么"></a>AOT，JIT是什么</h1><p>程序主要有两种运行方式：静态编译与动态解释。</p><p>静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；<br>而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。</p><span id="more"></span><blockquote><p>AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。</p></blockquote><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>这两种编译方式的主要区别在于是否在“运行时”进行编译。</p><h1 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h1><p>JIT优点：</p><ol><li>可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）</li><li>可以根据当前程序的运行情况生成最优的机器指令序列</li><li>当程序需要支持动态链接时，只能使用JIT</li><li>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</li></ol><p>JIT缺点：</p><ol><li>编译需要占用运行时资源，会导致进程卡顿</li><li>由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡</li><li>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</li></ol><p>AOT优点：</p><ol><li>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗</li><li>可以在程序运行初期就达到最高性能</li><li>可以显著的加快程序的启动</li></ol><p>AOT缺点： </p><ol><li>在程序运行前编译会使程序安装的时间增加</li><li>牺牲Java的一致性</li><li>将提前编译的内容保存会占用更多的外存</li></ol><h1 id="JIT深度解析"><a href="#JIT深度解析" class="headerlink" title="JIT深度解析"></a>JIT深度解析</h1><p><img src="/../images/213b5edeabce499182278d7730227019.png" alt="213b5edeabce499182278d7730227019.png"></p><p>对于一个长期运行的Java进程来说，每次执行都要经过 解释器 将程序翻译成机器指令去执行，那么这个效率就不是很好，这也是为什么Java被吐槽慢的缘故，<br>所以为了解决这个问题，才出现了 JIT。对于一些热点代码（经常被执行的，for循环）的一些代码，在运行时，JVM会将这些代码编译成机器可以执行的机器码，并缓存起来，这样下次执行这些代码的时候，就不需要再经过 解释器去编译了，机器可以直接运行这段程序，提高性能，这个就被称为 即时编译器，简称 JIT编译器。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://blog.csdn.net/cristianoxm/article/details/126032096">JIT VS AOT</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API测试</title>
      <link href="/posts/873cc8b2/"/>
      <url>/posts/873cc8b2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="9种API测试"><a href="#9种API测试" class="headerlink" title="9种API测试"></a>9种API测试</h1><span id="more"></span><p><img src="/../images/c53f283e-6834-45b6-beb9-57b10b2a22fd_1280x1664.webp" alt="c53f283e-6834-45b6-beb9-57b10b2a22fd_1280x1664.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端架构</title>
      <link href="/posts/926db354/"/>
      <url>/posts/926db354/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五种前端架构"><a href="#五种前端架构" class="headerlink" title="五种前端架构"></a>五种前端架构</h1><span id="more"></span><p><img src="/../images/F_38UuNbEAACWtu.jpeg" alt="F_38UuNbEAACWtu.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API安全技巧</title>
      <link href="/posts/55de1c2a/"/>
      <url>/posts/55de1c2a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="API-安全的-12-个技巧"><a href="#API-安全的-12-个技巧" class="headerlink" title="API 安全的 12 个技巧"></a>API 安全的 12 个技巧</h1><span id="more"></span><p><img src="/../images/45d16bfb-c541-4c01-8574-63cc39a5c560_1280x1664.webp" alt="45d16bfb-c541-4c01-8574-63cc39a5c560_1280x1664.webp"></p><h1 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p>云冲印<br><img src="/../images/bg2014051202.png" alt="bg2014051202.png"></p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。<br>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。<br>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。<br>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。<br>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p><p>OAuth就是为了解决上面这些问题而诞生的。</p><p><img src="/../images/v2-fccac16d440911894f2ff356064563e9_1440w.webp" alt="v2-fccac16d440911894f2ff356064563e9_1440w.webp"><br>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/posts/50daec4/"/>
      <url>/posts/50daec4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="8-种常用网络协议"><a href="#8-种常用网络协议" class="headerlink" title="8 种常用网络协议"></a>8 种常用网络协议</h1><span id="more"></span><p><img src="/../images/20231021-bf786236-f777-481b-ba9e-65921c16752e.gif" alt="20231021-bf786236-f777-481b-ba9e-65921c16752e.gif"></p><h1 id="Cookies-与-Sessions"><a href="#Cookies-与-Sessions" class="headerlink" title="Cookies 与 Sessions"></a>Cookies 与 Sessions</h1><p><img src="/../images/c05744c903f54153a28805cd182107bb~tplv-obj_1280_1664.gif" alt="c05744c903f54153a28805cd182107bb~tplv-obj_1280_1664.gif"></p><h1 id="URL-URI-URN"><a href="#URL-URI-URN" class="headerlink" title="URL, URI, URN"></a>URL, URI, URN</h1><p><img src="/../images/0_cU9y8hm7YEjkVZBJ.webp" alt="0_cU9y8hm7YEjkVZBJ.webp"></p><h1 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h1><p><img src="/../images/1704001549342.gif" alt="1704001549342.gif"></p><h1 id="在浏览器中输入一个网址后到底发生了什么？"><a href="#在浏览器中输入一个网址后到底发生了什么？" class="headerlink" title="在浏览器中输入一个网址后到底发生了什么？"></a>在浏览器中输入一个网址后到底发生了什么？</h1><p><img src="/../images/8d954f9b42c64ea0ab9be4567e38f523~tplv-obj_550_715.gif" alt="8d954f9b42c64ea0ab9be4567e38f523~tplv-obj_550_715.gif"></p><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p><img src="/../images/1475ba84-8106-4d61-924e-6403cfdc1074_1280x1664.webp" alt="1475ba84-8106-4d61-924e-6403cfdc1074_1280x1664.webp"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/663267550">用一张动图解释 8 种常用网络协议</a></li><li><a href="https://blog.bytebytego.com/p/ep80-explaining-8-popular-network">EP80: Explaining 8 Popular Network Protocols in 1 Diagram</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024.01日记</title>
      <link href="/posts/2916158c/"/>
      <url>/posts/2916158c/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="6922e8c64a1faa1dc6299e779563a251e63e4cf6bd883a8a86cde813604e8fae">026422d16125c0ef5486e4aca3c5daf506eac8b704d20a3e10d8dbe17b8641d586f098f2562ff378c8eaefc40cd08645fcb781c0c27175247887a8fa63710904c5fb41cc2077160fcb551c7176b562e7f0b1d3a29e848d56e354e3210cfad118b2029c1e8a692a35b614a0c9f658fa58fea90d31e7290f42931238ec4b8ecacbf28732c97ffd1f634c82720f065aa369dda264374aa10d648358b07e415b465fa735ba3ad5f3c0dcb85a1da85c1629e757cf15c3aa70d7f2ede01d21306263745580f3ddb8adfdad4df15f8cd5a62dabd27318669f01bfd9d80108ba17b3ecc4d0010cf357661bd73574d737de338f905129fa9f61ee213252ddf169be1303ef7c61c013f649446b1155e49124866cea60ec9ae422a1566f1dce42d5a52f5c5ad263b1974f112503068e74595207f0b6c777672fb896401bd4bbf160f2e43b3e268379ea978c3ce3072d0b7d52dce565a0b8087ca2c3be10c693b18a9e665ece388b368e9a5b44fca3fdefbc5a705efa58edcf5f50f77497b2743375d76efa67334d3fc3d932bc61709a4daf29057da052acb035733c3858c2319a3a5a168d0f48687bf069591b918e4817d9b7c77a8cca05174885b07a1d6794caee7f2078a04b6b021714e7df893fd33b731c0cd97d1b5dbf75ede0b4d4a440e2a1f60be362e93d0f588b271031420e70be3f4578eb108ae2f5de645a1cab22fd3a4d30ae9d56bb6f1e41229c993bc9f45a1455b6cec1ea6d76e497293f190629dd9b55ab7dc1b1a653dfe685282a881288b203aa7dc0c2d557d1eccc168afb52c759f1597707b808a272a86a34fea71fb6a3f9fb1ee08dbcaa093c814611a91ca81bff0eca197be2f9d37a1a721a41f5e1d42a368eb2ab5fd764204ad48e56fa3fab363ee300e025cf4bbb9c4629c7417b15b54495aac1944d6aa3b2e4f67aa44e1579acd12ea40d2083ea228e3f5f2253f4c76ab31df9cf258b07dc7481d476117bea6806264ec126558fe635e87c9c1b424649770d572cd8cfea21b99dd6458380f5be84aa5157b4f75a397445666f7167fa35bf6cc84ae0610e677b3ce02a69e892a9df2b8bb2dfd33dd74a339241c2d6ca4f031818e73a7695551ad37059b0b3dc5ead02b90fa77f877b1c7939856ccf991adb6d160acf85a766d1b26f16e4200c9ec71f77bd4e7c8ab38368cb64c8ba9fa79333807fc9e17e9c63bd5729a1c835ba89ccd694a9d09321472aafc7f0ba07cb1ff1ef1c1b1b7ac9be7ae262f41da44e2ac3c15d91a1ccd66a45104a769bbb406ff9de5678326920c5f210e6ca3e73db12fae5f81ed2d07af8817dd7726f654e4219192623bb56428ded4e9814fc6c580399685cc25a3314c38c0d7d78d3a67d6eb36e08635216b433a96ac3d7665d4e8b89cd92c8d3f96c1087f8afaf346360f64ab811b83e63660e919ef662381d91ea21f995370f151153de015c6bbd6b82730271eb1afbc1f0cc208d8a8a1d45f5a21c7d7e3b83828ec98a30b283f152558e451f02474e8a8ec3872535e06d7f2799f08d085690a524710a4f2f4f60f9106503cb2ad0a1011c9ad3a711f0975f66233b4a4dc232ec4ff68c4bad5b75dafa9b45ee0f17675aa9dde99c122a8756571444c4ccbcf46423953191cbe68acc9908859cca976717a7cbfa68b585439fd2ad064aa6fd256e42efeeea7151cb37e608b111b81c05cf0e57112d2fba23838febb2278b6f3d4a3a7b49d7f8b62774a68341daf09b6b0fbba996f880ede3f49a33ff785151fce8f26c4c81981292de142ed10b0536b017cbcd985a79ebc9a47018d95c53f35cc07b993129777ab24a8b594b44b33f70546b21b242c27c8da6b09df23f7bd1a8b39f15795215b070207f9f01e3033204338813abbe4120f7daac963f73232908e366d29f87574b5989ff2e048eae52f13f7a01c264f96f293482311c59fddc3c61fcc221f180f70579cfa6acd944eb2137cb56901c3e6ee15c21863001a63647d265d469a510c60b017f0a62a12e11fc166b437bd7d6b3f3cc95d614a008f658cc34ccaf4568da4f7a3730fe44cae1496711dbc10b05b6651e4a69c07f2d2c593eb9794836b8833f943934cac7904ae255e3ceb680fe5ea294a54e151e6773a4e58b8d365acac11811c4791cf165bb69dfc0dc18597c0dad4c273b107e591717bd25eb5068cce151b1e8d874fb1774528ef276361fbe07c78daaa19f861cb201d51b72e13d4608dbc6e2308664f53319e798e37cd8b963a4f8152daa5966bc00f0c9c54fc22c3fc76fc44585781d00531702f18b4d2526b3c591f23a5dc2903bc23a8f7075b1168077658d90ed3dff2435ce54bdf7b8f1a0b5cb10bbdf281935957d3b3d476ffb9996b0c9c8924764dd9bcf0049ba01919f897ebd9ea49d0f78ddad25febae087e088842c10bd413559673cc9596eb2105c67f66ab1a454e39d0cb2800556d520981faac467814b219d4b16e45470acc5fe9f5b312b0abaeab98df3934b92f15892a852f1064446b6ac54e37330eee7d6f560e2717c06698071e755eea1bb1e1ef79e6e0a1071aec9ef918db875904933d3af7774708ccd39b56171fab4d01f6989dace0618ff12ae07ec13bf167de877d0ab83cfc835ed8f6a04fd31fdadb90395d73670d9c614dff8df245660d11f9dbc1d3ae404469389be454922e1957263227bd55a6ceb616f83c7576b1bcd78628a45b6497b9ddbd5b7df56d91b99ae72fd7e6e60c92db16a46ffcd03522e6c66da9136cfff1ea71aaf4176ac1dc69bf0a09610d6bc0cf6d4d316accaed5e0b5805add0aa096b2ce31f005285a53ece5422385a48b14f99b712b916d83755f0917b3e19082c0776260b6d2460377014dd218e3de94b3a5006b6ae391ac7fd86d2dfffeb714b1f7266fa288b08f40ad1c2e00b9663150d7a5cb4a4b8e6eb3ea1d8acae17147ca6f57d5c720d0bb197a0695975171e144b643efcaafd40d05d7531fd8b74d6ba8aebb174e78346870a04769550a6c58f122f80353d6145fbac4db9b41ee912652782f2379df05c4c36577e23dbefa0bd32bc159a25c48c3dad7b472a035a43e308f23c0dc1d36c19988253b72058ff00f41a395e8c7ab5cc4cedb1d2f0302002706167ede60234bb86f1013b30fb921b4e1e1c752ea865228c733b7ae22a693d487a5461d81213e47b5265b79a0cfa1ecdca3fe12e94f1d82aa65e2e64384f289349e7d99f81b1960e623d077ec286149375ca4d6d822b92cdfb1216c6de6cb3e365e9e4f5eb488e174f7dabe3ade88e186a541bfc39fcabe87daee705aa521cb27b7d4241a95fbe412d1232cad58c668188bbdb834b44e8e06be6460a9f927cb32267d54f606d182460e04e6842f4ee100f219ab7866f90dd2b5c6800149f0d0d582cd50ec7c3ff49b46dbdc2ed320da8ec38ee70e94a17bdd5337eff40fc2b8bba2815f31543e74345116d260ff4164c4568edc61375ea89462cacf776cfc8740c6a0070b6c414d3fe92da088b97d8c3f22a365f1216c4e5f5261ed3ee3090c949f1081c583b1cb75e269f58515d34095cc5642a8e2b46d31a716edf8a31d443c99bce5b7238a1735eff248a549c2a2969638e6eb2c6f928170b8a5c2a7010117ed611bb82ca8ea61982f3e66ea097678299107d6c5b0b934bb45ced4e0afb54d7a73eac1c4f53e8d060981f8ddfabcc46eaa459dd44376284ab0a0c72c887cd2ee65112f0adcc86bafa82dfadfadb5ace404b67bd3cd050a3defa02b464e6182c20d27f00143b9a4670a0737998d9752457bb3b224196bf3018a13ccef4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>V8技能树</title>
      <link href="/posts/e4409905/"/>
      <url>/posts/e4409905/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是-V8"><a href="#什么是-V8" class="headerlink" title="什么是 V8?"></a>什么是 V8?</h1><p>V8 是 JavaScript 虚拟机的一种。将人类能够理解的编程语言 JavaScript，翻译成机器能够理解的机器语言。</p><span id="more"></span><p><img src="/../images/download.jpg" alt="download.jpg"></p><h1 id="V8编译流水线"><a href="#V8编译流水线" class="headerlink" title="V8编译流水线"></a>V8编译流水线</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(1).jpeg" alt="下载 (1).jpeg"></p><ol><li>初始化基础环境；</li><li>解析源码生成 AST 和作用域；</li><li>依据 AST 和作用域生成字节码；</li><li>解释执行字节码；监听热点代码；</li><li>优化热点代码为二进制的机器代码；</li><li>反优化生成的二进制机器代码。</li></ol><p>这里你需要注意的是，JavaScript 是一门动态语言，在运行过程中，某些被优化的结构可能会被 V8 动态修改了，这会导致之前被优化的代码失效，如果某块优化之后的代码失效了，那么编译器需要执行反优化操作。</p><p>编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内<br>联缓存等等。</p><p>要想充分了解 V8 是怎么工作的，除了要分析编译流水线，我们还需要了解另外两个非常重要的特性，那就是事件循环系统和垃圾回收机制。</p><h1 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h1><p><img src="/../images/%E4%B8%8B%E8%BD%BD%20(2).jpeg" alt="下载 (2).jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> TS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> V8 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
